{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>To showcase the knowledge we gained from the course EEC 172 \u2013 Embedded Systems, we exercise the skills taught in labs to design and implement a final project with increased complexity and creativity. Our project is titled Pok\u00e9mini Go, an application that is inspired by the popular game Pok\u00e9mon Go. For context, Pok\u00e9mon Go is a mobile application that uses augmented reality and the phone's GPS sensor to spawn collectible characters, called Pok\u00e9mon, on a real-world map. To capture Pok\u00e9mon, users must physically walk to real-world locations where the characters had spawned. As the user physically moves, their real-time location updates on a map displayed in the application. When the user reaches close proximity to that Pok\u00e9mon, they can attempt to catch it and add it to their collection. Our project Pok\u00e9mini Go is a simplified version of Pok\u00e9mon Go. Pok\u00e9mini Go implements the core functionality of Pok\u00e9mon Go by spawning Pok\u00e9mon characters at real coordinates. Users must walk to these coordinates to battle the Pok\u00e9mon and add it to their collection.</p>"},{"location":"#demo","title":"Demo","text":""},{"location":"#capturing-a-pokemon","title":"Capturing a Pok\u00e9mon","text":""},{"location":"#fleeing-a-pokemon","title":"Fleeing a Pok\u00e9mon","text":""},{"location":"#map-page-functionality","title":"Map Page Functionality","text":""},{"location":"bill-of-materials/","title":"Bill of Materials","text":""},{"location":"bill-of-materials/#available-lab-materials","title":"Available Lab Materials","text":"<p>The following list specifies necessary hardware components that were made available without purchase from the lab section. We utilized the CC3200 LaunchPad and OLED that were provided during the first session of lab 1 (\"Development Tools Tutorial and Lab Introduction\"). Furthermore, we used the IR remote, decoder, resistor, and capacitor that were handed out for lab 3 (\"IR Remote Control Texting Over a UART Link\"). To solder pin headers onto the GPS and compass modules, we used the soldering iron and solder wire that were available in the lab room.</p> <ul> <li>1 CC3200 LaunchPad (Lab Provided)</li> <li>1 AT&amp;T S3 IR universal remote control to provide user input (Lab Provided)</li> <li>1 Vishay TSOP383xx to decode IR remote signals (Lab Provided)</li> <li>1 100\u03a9 resistor to construct a low-pass filter for filtering noise on the IR decoder\u2019s power source (Lab Provided)</li> <li>1 100\u00b5F capacitor to construct a low-pass filter for filtering noise on the IR decoder\u2019s power source (Lab Provided)</li> <li>1 RGB 128x128 Adafruit SSD1351 OLED Display to display pages for the user interface (Lab Provided)</li> <li>1 soldering iron to solder pin headers onto the GPS and compass modules (Lab Provided)</li> <li>1 pack of solder wire to solder pin headers onto the GPS and compass modules (Lab Provided)</li> </ul> <p>Furthermore, we already owned an 830-tie point breadboard and a set of breadboard jumper wires to physically connect the components. We also owned pin headers to solder onto the GPS and compass modules.</p>"},{"location":"bill-of-materials/#purchased-equipment","title":"Purchased Equipment","text":"<p>In addition to the equipment we personally owned or acquired from lab, we needed three other products that required purchasing: a breadboard power supply, GPS module, and compass module (to prepare for attempting our compass stretch goal). In total, we spent $42.47 excluding tax.</p>"},{"location":"bill-of-materials/#breadboard-power-supply","title":"Breadboard Power Supply","text":"<p>A breadboard power supply is required to make our device an interactive handheld device so that the Launchpad does not need to be connected to a computer for power. The SunFounder BreadVolt module consists of a recharge- able battery and two power outputs for 5-volts and 3.3-volts. The 5-volt output supplies power to the GPS module. The 3.3-volt output supplies power to the LaunchPad, IR receiver, and OLED display. This product was purchased on Amazon for $9.99 at this link.</p>"},{"location":"bill-of-materials/#gps-module","title":"GPS Module","text":"<p>To retrieve the user\u2019s real-time location as they physically move, our project requires a GPS module so we can read the latitude and longitude. We purchased a HGLRC M100-5883 GPS module on Amazon for $19.99 at this link.</p>"},{"location":"bill-of-materials/#compass-sensor","title":"Compass Sensor","text":"<p>For a stretch goal, we thought about integrating a compass sensor for rendering an arrow that directs the user to the nearest Pok\u00e9mon. Thus, we bought a Waveshare Bosch BMM150 3-axis digital compass sensor. The product was purchased on Amazon for $12.49 at this link.</p>"},{"location":"challenges/","title":"Challenges","text":"<p>We encountered a couple of major challenges during the implemen- tation of our project.</p>"},{"location":"challenges/#unable-to-connect-to-common-https-endpoints","title":"Unable to connect to common HTTPS endpoints","text":"<p>Our initial idea was to have the Launchpad make HTTPS requests to an AWS Lambda endpoint. AWS Lambda is a \"serverless\" compute service. That is, it runs a defined function when an HTTP endpoint is called, and thus allows us to write API handlers without having to manually configure and maintain any extra server infrastructure. However, we encountered major difficulties when attempting to establish a TLS connection to the Lambda endpoint. At first, we attempted establishing a TLS connection to the lambda endpoint using the same TLS root, client, and private certificates that we had configured from Lab 4. However, we received error code <code>-6</code> from the function <code>sl_Connect()</code>, indicating that a connection could not be established on the configured TLS socket. We then attempted manually downloading and flashing the AWS CA Root Certificate onto the Launchpad. We verified that the certificate was in DER format and also attempted consolidating it with intermediary certificates used on our particular Lambda endpoint into other DER files. However, none of these certificate chains permitted a successful TLS connection. After reading through AWS Lambda TLS documentation on supported TLS ciphers, we hypothesized that perhaps the default directly-exposed Lambda certificate required the use of recent ciphers that the Launchpad did not support. Thus, we also tried configuring an API Gateway, which is an AWS service for a REST API front-end that allows for more fine-grained configuration of API endpoints. In particular, API Gateway supports lower security levels and older ciphers to be explicitly configured on select endpoint paths to support older clients. However, we could not establish a TLS connection to the API Gateway either.</p> <p>We also considered using MQTT and just using the IoT shadow endpoint as previously used in Lab 4. For MQTT, we read through the sample client code provided in the TI SDK. However, we realized that the MQTT code required the use of lightweight operating systems, namely Ti-OS or FreeRTOS, which use hardware interrupts to implement pre-emptive scheduling for multitasking. If we were to adapt either of the recommended MQTT clients, then we would have to rewrite all of our logic to use those operating systems, and given that we had around 4 days at that point to get a fully working project while balancing other classes, we decided we did not have enough time to experiment with MQTT.</p> <p>The other option was using IoT shadow. However, we determined that IoT shadow would add another layer of indirection and thus complexity, since we would still need some kind of business logic layer such as a Lambda function to compute operations on the database, and as well as maintaining the separate <code>reported</code> and <code>desired</code> IoT Shadow states.</p> <p>Thus, we decided instead to simply implement an unsecured HTTP endpoint on an AWS EC2 VPS instance that we already rent yearly. This is where we decided to use Express.JS to implement this HTTP API endpoint, and so then we have this service scheduled to automatically run using Node.JS on the VPS.</p> <p>This was a simple solution permitted under the project constraints that allowed us to hit all of our minimal, target, and numerous of our stretch goals on-time.</p>"},{"location":"challenges/#unable-to-receive-a-full-nmea-sentence","title":"Unable to receive a full NMEA sentence","text":"<p>Initially when we attempted reading the GPS module NMEA sentences over UART and printing these sentences out into the computer UART console, we discovered that we were never reading a full NMEA sentence. Specifically, our GNGGA sentence would always cap at 16 bytes/ASCII characters.</p> <p>We remembered from Lab 3 that this maximum value was suspiciously similar to the buffer size of the UART FIFO buffer. Thus, we immediately suspected a similar issue as to what we had in Lab 3, where our RX buffer interrupt handler was not reading received bytes fast enough to clear the buffer and allow for the rest of the message to be received.</p> <p>Firstly, we tried setting the baudrate to the minimum allowed setting. However, for our particular board and chip, the HGLRC M100-5883 with a UBlox M10 baseband chip, the minimum UART speed that we were able to observe a valid response was 19200 baud. Even at this baudrate, we still were only able to read the first 16 characters of any NMEA message.</p> <p>Then, we decided another technique to also reduce the total number of interrupts that we would have to trigger. Instead of triggering the UART RX interrupt handler on every received byte, we instead configured our RX buffer interrupt handler to run only after every 8th received byte - a half full buffer:</p> <pre><code>MAP_UARTFIFOLevelSet(UARTA1_BASE, UART_FIFO_TX4_8, UART_FIFO_RX4_8);\n</code></pre> <p>After setting this new interrupt trigger, we were able to observe full NMEA sentences for all transmitted sentences. We hypothesize that this made such a big difference because it takes a significant amount of time to altogether raise the interrupt line, enter the interrupt service routine, run the peripheral code we implement to read the buffer characters and parse them, and then return control back to the main process. Thus, we divide the total amount of interrupt handles by a factor of 8, significantly increasing the rate at which we can handle incoming UART data.</p> <p>Lastly, although we at first tested this working solution at 19200 baud, we then decided to increase the baudrate back up to 57600 baud, which is the highest baud at which we were able to consistently receive correct NMEA sentences. The reason for attempting to drive the baudrate back up is because of the high throughput of data transmitted by the GPS module. Thus, to not hog resources away from other actions in the game loop, we try to make the transmission and receipt of GPS data as fast as possible. As is discussed above, we also combine this with the GPS module timeout where we disable the GPS UART RX interrupt when not in use.</p>"},{"location":"description/","title":"Description","text":"<p>To showcase the knowledge we gained from the course EEC 172 \u2013 Embedded Systems, we exercise the skills taught in labs to design and implement a final project with increased complexity and creativity. Our project is titled Pok\u00e9mini Go, an application that is inspired by the popular game Pok\u00e9mon Go. For context, Pok\u00e9mon Go is a mobile application that uses augmented reality and the phone's GPS sensor to spawn collectible characters, called Pok\u00e9mon, on a real-world map. To capture Pok\u00e9mon, users must physically walk to real-world locations where the characters have spawned. As the user physically moves, their real-time location is updated on a map displayed in the application. When the user reaches close proximity to that Pok\u00e9mon, they can attempt to catch it and add it to their collection. Our project Pok\u00e9mini Go is a simplified version of Pok\u00e9mon Go. Pok\u00e9mini Go implements the core functionality of Pok\u00e9mon Go by spawning Pok\u00e9mon characters at real-world coordinates. Users must walk to these coordinates to battle the Pok\u00e9mon and add it to their collection.</p>"},{"location":"description/#features","title":"Features","text":""},{"location":"description/#frontend","title":"Frontend","text":"<p>The user interface to Pok\u00e9mini Go is a 128x128 OLED display. We implement four different OLED pages \u2013 a landing page, collection page, fight or flee page, and fight page. We describe these pages in greater detail below.</p> <ol> <li>When the program starts finishes setup, the user is navigated to the landing    page. The landing page displays the board's real-time location in latitude    and longitude. Furthermore, the coordinates of the Pok\u00e9mon closest to the    user are displayed. This informs the user of the nearest location they can    physically approach to fight a Pok\u00e9mon. The nearest Pok\u00e9mon is calculated on    the server, and the client periodically requests that data.</li> <li>To view all the Pok\u00e9mon that the user has collected, they can navigate to a    collection page that displays character sprites for each Pok\u00e9mon in their    collection. </li> <li>When the user enters a 10-meter radius of a Pok\u00e9mon, a \"fight or flee\" page    is rendered. The user is informed that a Pok\u00e9mon nearby has been detected.    The user utilizes an IR remote to input whether they will flee or fight the    Pok\u00e9mon. If the user flees, they are redirected to the landing page.    Otherwise, the user is redirected to a fight page, where they engage in a    game to collect that Pok\u00e9mon.</li> <li>When the user is redirected to the fight page, they participate in a    turn-based attack mini-game, where they use the IR remote to provide user    input. Pressing a button from 0 to 9 on the IR remote will randomly harm    either the user or the enemy. Both the user and the enemy start with four    hearts. If the enemy is the first to lose all their hearts, the user wins and    collects the Pok\u00e9mon that had activated the fight. The user is redirected to    the collection page, where they can view the new Pok\u00e9mon in their collection.    Otherwise, if the user is the first to lose all their hearts, the Pok\u00e9mon    \"escapes\", and the user loses the opportunity to collect that Pok\u00e9mon. They    are subsequently redirected to the landing page.</li> </ol> <p>We also deploy a web application that displays a real-time map of all Pok\u00e9mon in our database. In addition to the coordinates displayed on the OLED landing page, the map serves as another interface to determine the locations at which a user can battle a Pok\u00e9mon. The map also displays a location marker for the device on which the user has accessed the website. As the user physically moves, their real-time location is updated on the map. </p>"},{"location":"description/#backend","title":"Backend","text":"<p>We implement REST APIs on an Express server that is hosted on a VPS (Virtual Private Server), and use AWS DynamoDB to store Pok\u00e9mon and user data. We provide the following description as a brief overview of the high-level functionality that our backend offers. When a LaunchPad runs our application, its MAC address is obtained to check whether this is a new or existing user. If this is a new LaunchPad that runs our application, the server creates a unique user on AWS DynamoDB, and the new user starts with an empty collection. Otherwise, if an existing LaunchPad has already run our application, their collection of Pok\u00e9mon is retrieved from the database when the program is initialized. The user's collection of Pok\u00e9mon will be rendered on the collection page. As the user physically moves, the LaunchPad periodically makes HTTP GET requests for the Pok\u00e9mon closest to them. When the server makes these distance calculations, it performs additional calculations to ensure that enough Pok\u00e9mon have spawned around the user. In particular, the server will calculate if there are at least 6 existing Pok\u00e9mon in a 100 meter radius of the user; if this threshold is not met, the server generates more Pok\u00e9mon in the user's 100 meter radius. If the user is within a 10-meter radius of a Pok\u00e9mon, the server informs the LaunchPad that a fight can be activated. The \"fight or flee\" page is rendered on the OLED, and the user has the choice to flee from the Pok\u00e9mon or fight via a turn-based attack mini-game. If the user fights the Pok\u00e9mon and wins, the Pok\u00e9mon is added to the user's collection. Both a fight and flee will result in the Pok\u00e9mon being deleted from the database of available characters to be battled.</p>"},{"location":"description/#hardware","title":"Hardware","text":"<p>We use two sensing devices in our implementation of Pok\u00e9mini Go \u2013 an IR receiver and GPS module.</p>"},{"location":"description/#ir-receiver","title":"IR receiver","text":"<p>An AT\\&amp;T IR universal remote control is used to send signals to an IR receiver. We incorporate code from Lab 3 (\"IR Remote Control Texting Over a UART Link\") to decode signals for identifying specific button presses. To reduce the noise from the power source, the IR receiver is connected to a low-pass filter composed of a 100 micro-farad capacitor and 100 ohm resistor. We press buttons on the IR remote to get user input for the following functionalities: choosing to fight or flee, switching between the landing page and collection page, and playing the turn-based attack mini-game on the fight page.</p>"},{"location":"description/#gps-module","title":"GPS module","text":"<p>We utilize a GPS module to get the user's location in latitude and longitude. The module reads radio signals emitted by satellites, requiring at least three satellites to calculate a position by trilateration. After the GPS successfully finds a fix, the module transmits data using the NMEA-0183 format. Each NMEA-0183 sentence begins with the character \"$\" followed by the talker identifier and the sentence type. For our project, we parse data from the \"GNGGA\" sentence. The talker identifier \"GN\" indicates that multiple satellite systems, particularly from several constellations of the Global Navigation Satellite Systems (GNSS), are used to produce data (footnote). \"GGA\" denotes the sentence type as Global Positioning System Fix Data, which consists of 16 fields. The third and fifth fields are latitude and longitude, respectively.</p>"},{"location":"description/#protocols","title":"Protocols","text":"<p>Two hardware communication protocols are used to transmit information between the MCU and peripheral devices. We use Serial Peripheral Interface (SPI) to communicate between the CC3200 LaunchPad and OLED display. Furthermore, we use UART to read data from the GPS module and debug to a local console.</p>"},{"location":"description/#serial-periphal-interface-spi","title":"Serial Periphal Interface (SPI)","text":"<p>Serial Peripheral Interface (SPI) is a full-duplex synchronous communication protocol, which is used to transmit data between the CC3200 LaunchPad and OLED display. The protocol implements a master-slave interface, where the master (i.e. MCU) initiates communication and the slave (i.e., OLED display) responds to these requests. SPI data transmissions do not follow a standardized format but comply with device specifications. The protocol uses four point-to-point unidirectional wires as described below.</p> <ol> <li>Serial Clock (SCK): A master-to-slave wire that transmits a master-generated    clock signal.</li> <li>Slave Select (SS): A master-to-slave wire that selects the specific slave    device to enable communication with.</li> <li>Master-Out Slave-In (MOSI): A master-to-slave wire that transmits data from    the master to a slave device.</li> <li>Master-In Slave-Out (MISO): A slave-to-master wire that transmits data from a    slave device to the master.</li> </ol>"},{"location":"description/#universal-asynchronous-receivertransmitter-uart","title":"Universal Asynchronous Receiver/Transmitter (UART)","text":"<p>Universal Asynchronous Receiver/Transmitter (UART) is an asynchronous serial communication protocol that uses two one-way wires, a connection for transmitting data (TX) and another for receiving data (RX). As an asynchronous protocol, the sender and receiver agree on a baud rate to indicate how often each device should sample from their own local clocks. The sender initiates transmission by sending a predetermined start symbol, which informs the receiver to begin sampling data by the baud rate. After transmission of an $n$-symbol data frame, the sender sends a stop symbol to end communication. We make the distinction here between symbol and bit because baud rate describes sampled symbols per second, not necessarily binary bits per second. However, most electrical standards used in implementing UART use binary voltage symbols.</p>"},{"location":"description/#software","title":"Software","text":""},{"location":"description/#code-composer-studio-and-cc3200-sdk","title":"Code Composer Studio and CC3200 SDK","text":"<p>Our project is implemented in the C programming language, which we compile and load onto the CC3200 via the Code Composer Studio IDE. We build on top of the starter code provided in lab 4 (\"Introduction to AWS and RESTful APIs\") and import code from lab 2 (\"Serial Interfacing with SPI and I2C\") and lab 3 (\"IR Remote Control Texting Over a UART Link\"). In particular, lab 2 provides the OLED driver code, and our implementation of writing commands and data to the display. Our lab 3 code contains the logic for decoding IR remote signals to determine which button has been pressed. Furthermore, it implements UART interrupts for communicating with another peripheral device. We extend the application <code>aws-rest-api-ssl-demo</code> from lab 4, which contains the driver code for Texas Instruments SimpleLink CC3200 SoC, and is what we use to network with the internet using a WLAN adapter.</p>"},{"location":"description/#cc3200tool","title":"cc3200tool","text":"<p>The <code>cc3200tool</code> is a serial flash utility that allows us to program flash memory and open a pyserial terminal for UART communication between the CC3200 SoC and our local machine. The command-line utility can be installed from this repository. To open a serial port on our local machine, we execute the following commands and specify our baud rate as 115200.</p> <pre><code>conda activate cc3200\ncc3200tool term 115200\n</code></pre> <p>We also use the <code>cc3200tool</code> to write to flash memory, ensuring that our project is stand-alone. As mentioned in Lab 1 (\"Development Tools Tutorial and Lab Introduction\"), we run the following command to write <code>pokemon-go.bin</code> to <code>/sys/mcuimg.bin</code>. After the program has been written to non-volatile memory, the application will run once the LaunchPad is connected to power. Pressing the \"Reset\" button will restart the application. </p> <pre><code>conda activate cc3200\ncc3200tool --sop2 \\~dtr --reset prompt \\\n    format_flash --size 1M \\\n    write_file pokemon-go.bin /sys/mcuimg.bin\n</code></pre>"},{"location":"description/#aws-dynamodb","title":"AWS DynamoDB","text":"<p>AWS DynamoDB is used to store Pok\u00e9mon and user data on the cloud. With this NoSQL serverless database, we create two tables \u2013 <code>PokemonTable</code> and <code>UserTable</code>. <code>PokemonTable</code> consists of entries for each Pok\u00e9mon that has spawned and is available to be captured. <code>UserTable</code> contains an entry for every unique LaunchPad that has run our application and tracks all Pok\u00e9mon that each user has collected. </p>"},{"location":"description/#rest-apis-and-express","title":"REST APIs and Express","text":"<p>REST (Representational State Transfer) is a common set of guidelines for writing Web APIs. Specifically, all REST APIs have stateless calls at the API level. This means that a single call transfers some state either from the server or from the client, and without the value dependent on the status of any other call. Furthermore, REST APIs are conventionally implemented using HTTP with semantically meaningful verbs and query parameters, and with JSON being the most common payload data format for transmitting structured or relational data.</p> <p>We use Node.js and TypeScript to create an Express server, where we implement REST APIs to handle HTTP requests. To retrieve, delete, update, and perform calculations on data within AWS DynamoDB, we write REST APIs to interface the LaunchPad with the database. </p>"},{"location":"design/","title":"Design","text":""},{"location":"design/#functional-specification","title":"Functional Specification","text":""},{"location":"design/#launchpad-functional-description","title":"LaunchPad Functional Description","text":"<p>As specified in the Description section, a state machine transitioning between 4 different pages is implemented. These four pages are the landing page, the collection page, the fight-or-flee page, and the fight page.</p> <p>To begin with, when the board is powered on, the system does not transition to one of the 4 pages just yet, but instead enters a loop to attempt connecting to the pre-configured WiFi network. In this loop, the text <code>Connecting to Wifi...</code> is printed on the top of the OLED screen. Then, when the LaunchPad is finally able to connect to the specified network, then the state transitions into the initial landing page.</p> <p>In the landing page, we display the title \"Pokemini Go\" in a custom font, with a picture of a Pikachu Pok\u00e9mon in the bottom right. Then, we also show the user's GPS coordinates and the enemy's GPS coordinates on the left of the screen. On the bottom of the screen, we show an indication that pressing the number button <code>1</code> on the IR remote will switch pages to the collection page.</p> <p></p> <p>In the collection page, we show a grid of Pok\u00e9mon icons corresponding to all of the Pok\u00e9mon that the user has collected. These Pok\u00e9mon are stored in the DynamoDB document corresponding to the current LaunchPad. Upon accessing the collection page, an HTTP GET request to route <code>/users/&lt;string:userId&gt;</code> is sent to the Express.JS server to retrieve all of the Pok\u00e9mon in the user's collection. The <code>userId</code> is uniquely given by the MAC address of the LaunchPad's WiFi chip, serialized into a hexadecimal string. From the collection page, the user can navigate back to the landing page by pressing the number button <code>2</code> on the IR remote.</p> <p></p> <p>In either the landing page or the collection page, a loop is run in the background where approximately every 5 seconds, the nearby Pok\u00e9mon are queried from the Express.JS server. This query is executed by making an HTTP GET request to the route <code>/pokemon/nearby</code> on the Express.JS server.</p> <p>The response from the server includes the GPS coordinates of the nearest Pok\u00e9mon to the LaunchPad, the ID of the Pok\u00e9mon, and also a boolean flag named <code>shouldActivate</code> indicating whether that Pok\u00e9mon is near enough to the LaunchPad to trigger a \"fight-or-flee\" activation. The new enemy's GPS coordinates are applied to the landing page state. Then, if <code>shouldActivate</code> is true, a state transition is triggered to enter the fight-or-flee page.</p> <p></p> <p>In the fight-or-flee page, we render text \"Pokemon Detected Nearby\" in a custom font in the center of the screen. Then right below, we indicate that the user can press the numeric button <code>1</code> on the IR remote to fight the Pok\u00e9mon, or that they can press the numeric button <code>2</code> on the IR remote to flee the Pok\u00e9mon.</p> <p>While in the fight-or-flee page, the background loop of querying for nearby Pok\u00e9mon is halted. This way, the LaunchPad does not receive a duplicate notification to fight another Pok\u00e9mon. The fight-or-flee page will stay active until the user takes an action to navigate away from it.</p> <p>If the user presses <code>2</code> to flee the Pok\u00e9mon, then an HTTP DELETE request is sent to the route <code>/pokemon/&lt;string:pokemonId&gt;</code> with the given ID of the nearest Pok\u00e9mon that triggered the fight-or-flee page. This will cause the Pok\u00e9mon to be deleted from the DynamoDB store and thus from the map. Then, the LaunchPad state will transition back to the landing page.</p> <p>If the user presses <code>1</code> to fight the Pokemon, then the LaunchPad state transitions to the fight page.</p> <p>In the fight page, we render four hearts on the top of the screen representing the user's health, and four hearts on the bottom of the screen representing the enemy's health.</p> <p>Then, we randomly assign the 10 numeric buttons on the IR remote to either trigger the user's health to decrease by one, or the enemy's health to decrease by one. To ensure that a win or loss is guaranteed without ties, we ensure that 5 of the buttons are assigned to decrease a user heart and that the other 5 buttons are assigned to decrease an enemy heart. Given the four hearts for each user, each user starts with a health value of 4. By pressing a button, either the user's health will randomly go down by 1, or the enemy's health will randomly go down by 1. The IR remote's number button actions are set at random whenever the fight state is entered. Then, when a number button is pressed, the press is recorded. A number cannot be re-pressed within the fight page. Thus, the user must exhaust all the number buttons until either the user loses all of their hearts or the enemy loses all of their hearts.</p> <p>While in the fight page, the background process for querying the server for nearby Pok\u00e9mon is halted. This way, the user will not be prompted to attack another Pok\u00e9mon while they are still battling the current Pok\u00e9mon.</p> <p></p> <p>If the user loses all of their hearts, then the resulting behavior is similar to that of if the user decided to flee in the fight-or-flee page.</p> <p>That is, an HTTP DELETE request will be made to the route <code>/pokemon/&lt;string:pokemonId&gt;</code> on the Express.JS server to delete the Pok\u00e9mon from the DynamoDB Pok\u00e9mon collection, representing the Pok\u00e9mon fleeing. Then, the LaunchPad state will transition back to the landing page.</p> <p>If the enemy loses all of their hearts, then an HTTP POST request will be made to the route:</p> <pre><code>/users/&lt;string:userId&gt;/pokemon/&lt;string:pokemonId&gt;\n</code></pre> <p>This will cause the Pok\u00e9mon to be removed from the DynamoDB Pok\u00e9mon collection and thus be removed from the map, but the Pok\u00e9mon will then also be added to the user's Pok\u00e9mon collection, signifying that the user has collected that Pok\u00e9mon. Then, the LaunchPad state will transition to the collection page to show the newly collected Pok\u00e9mon.</p> <p>Here, we show an image of what the fight page looks like immediately after the enemy loses all of their hearts, indicating a user win:</p> <p></p>"},{"location":"design/#expressjs-server-functional-description","title":"Express.JS Server Functional Description","text":"<p>The REST API server endpoint that processes the LaunchPad's network requests is written in Express.JS, a common Node.JS framework for writing web server applications. Node.JS is a server runtime that allows writing JavaScript or TypeScript code in a server non-browser environment.</p> <p>In Express.JS, API behavior is written in a declarative and asynchronous format, where function handlers are given to each particular route that the server should implement. For our application, we implement four distinct routes.</p> <ol> <li><code>HTTP GET</code> request to the route <code>/pokemon/nearby</code> will return the nearest     Pok\u00e9mon to the requesting user. We also include some lazy-loaded behavior     within this call to manage Pok\u00e9mon map state, as will be discussed later.</li> <li><code>HTTP GET</code> request to the route <code>/users/&lt;string:userId&gt;</code> will return a list    of all Pok\u00e9mon that are currently stored in the specified user's collection.</li> <li><code>HTTP DELETE</code> request to the route <code>/pokemon/&lt;string:pokemonId&gt;</code> will delete    the specified Pok\u00e9mon from the DynamoDB Pok\u00e9mon collection, thus removing the    Pok\u00e9mon from the map.</li> <li><code>HTTP POST</code> request to the route    <code>/users/&lt;string:userId&gt;/pokemon/&lt;string:pokemonId&gt;</code> will cause the specified    Pok\u00e9mon to be added to the specified user's collection, and for the Pok\u00e9mon    to also be deleted from the Pok\u00e9mon collection to remove it from the map.    This route is for \"catching\" the Pok\u00e9mon.</li> </ol> <p>For the <code>HTTP GET</code> request to the route <code>/pokemon/nearby</code>, the server expects two URL query parameters included in the request: longitude and latitude numeric values that correspond to the GPS coordinates of the requesting user. As an example, a fully formatted call might have a URL that looks as follows:</p> <pre><code>http://&lt;server_address&gt;/pokemon/nearby?latitude=37.000000&amp;longitude=-121.000000\n</code></pre> <p>If the query parameters are not given, then the web server returns a <code>400 Bad Request</code> error.</p> <p>After parsing the user's coordinates, then the server queries DynamoDB for all Pok\u00e9mon within a 100-meter radius of the user's GPS coordinates. If there are less than 6 Pok\u00e9mon within the 100-meter radius of the user's coordinates, then the server requests for more Pok\u00e9mon to be created such that the 6 Pok\u00e9mon threshold quantity is met. These new Pok\u00e9mon are created at a radius of at least 30-meters away from the user, and within the 100-meter outer radius. The Pok\u00e9mon are generated at least 30-meters away so that the user does not immediately trigger a fight with another Pok\u00e9mon, where we force the user to walk in order to reach fighting radius of a newly generated Pok\u00e9mon. In the server, we set the fight activation radius to be 10-meters. That is, if the server calculates that the user is within 10-meters of the closest Pok\u00e9mon, then the flag <code>shouldActivate</code> is set to true in the response to indicate that the LaunchPad should transition to the fight-or-flee page.</p> <p>We set the spawning radius to be 30-meters instead of 10-meters away from the user's GPS coordinates to give a margin of 20-meters. This margin accounts for the imprecision of the GPS sensor on the LaunchPad, where the position slightly jumps around as the local coordinates are polled. This way, we can prevent an accidental immediate trigger of a Pok\u00e9mon that is truly outside of the user's 10 meter activation radius, but that otherwise may have been accidentally triggered due to the user's GPS coordinates being transiently reported as closer to the Pok\u00e9mon than the user actually is.</p> <p>Finally, before returning the nearest Pok\u00e9mon information, all of the additional Pok\u00e9mon inside of the 30-meter margin-activation radius are removed from the DynamoDB Pok\u00e9mon collection. That is, if there is a single Pok\u00e9mon inside of the 30-meter radius, then that Pok\u00e9mon is returned and not deleted. If there is more than one Pok\u00e9mon inside of the 30-meter radius, then the closest of those Pok\u00e9mon is returned, and then the other Pok\u00e9mon are deleted. If there are no Pok\u00e9mon inside of the 30-meter radius, then trivially none of the Pok\u00e9mon are deleted.</p> <p>The reason for this behavior is so that after the user fights or flees the nearest Pok\u00e9mon inside of their 10-meter activation radius, then the user will not be immediately triggered to fight another Pok\u00e9mon that is also within the margin-activation radius.</p> <p>Finally, the nearest Pok\u00e9mon is then returned to the user.</p> <p>For the <code>HTTP GET</code> request to <code>/users/&lt;string:userId&gt;</code>, the server queries DynamoDB for the list of all Pok\u00e9mon that are stored in the user's document. These Pok\u00e9mon are then simply returned back to the user.</p> <p>For the <code>HTTP POST</code> request to <code>/users/&lt;string:userId&gt;/pokemon/&lt;string:pokemonId&gt;</code> the specified Pok\u00e9mon is retrieved from the DynamoDB Pok\u00e9mon collection, deleted from the Pok\u00e9mon collection, and then re-inserted into the user's document.</p> <p>For the <code>HTTP DELETE</code> request to <code>/pokemon/&lt;string:pokemonId&gt;</code>, the specified Pok\u00e9mon is directly deleted from the DynamoDB Pok\u00e9mon collection.</p> <p>For each of the above calls, the lower-level details of the response format is discussed in the Implementation section.</p>"},{"location":"design/#website-functional-description","title":"Website Functional Description","text":"<p>For the website that we implement, we use the React.JS website framework and Vite packaging system to implement a world-map interface that shows all of the Pok\u00e9mon and their locations in close to realtime.</p> <p>In particular, we leverage the Google Maps API to render a React component for a Google Map that uses the full view-port of the browser window. Then, we render a pin for the user's current location onto the map, and then we render all of the Pok\u00e9mon from the DynamoDB Pok\u00e9mon collection onto the map, using downloaded images of the Pok\u00e9mon and rendering those Pok\u00e9mon to their respective GPS coordinates on the map.</p> <p>In a background loop, we update the user's shown location and the status of all Pok\u00e9mon every 5 seconds. In the accompanying website report to this final report document, we embed our map into a page on that website.</p> <p>Below we show an example of what our map looks like:</p> <p></p>"},{"location":"design/#system-architecture","title":"System Architecture","text":"<p>Zooming out from the specific implemented behavior, the high-level system architecture involves the peripheral I/O devices connected to the LaunchPad, the LaunchPad itself, the Express.JS server, the AWS DynamoDB schema, and the React.JS map page.</p> <p>To begin with, we consider both the IR sensor and the GPS module to be input peripherals. The IR sensor detects button presses from the AT&amp;T Universal IR Remote and sends those inputs to the LaunchPad where the game business logic then updates game state in response to those presses.</p> <p>The GPS module continuously samples the user's GPS coordinates by using satellite trilateration, and then sends these samples to the game business logic as well over UART.</p> <p>Next, the output peripheral on the LaunchPad is the OLED display. We preprocess downloaded images from the internet into RGB bitmaps that are stored in C arrays. Then, these images are rendered onto the screen depending on game state.</p> <p>As is described in the functionality section, we implement an Express.JS game server that communicates bidirectionally both with the LaunchPad and also with the AWS DynamoDB database.</p> <p>Then, we implement a data schema for our DynamoDB tables. In particular, we use two collections: a Users collection that stores one document per user, and a Pok\u00e9mon collection that stores one document per each spawned Pok\u00e9mon on the map.</p> <p>Finally, we implement a front-end map page using React.JS and the Google Maps API which reads the data stored in AWS DynamoDB to visualize the global state of the game on the map.</p> <p>The implementation details for each of these major components are discussed in the Implementation section.</p>"},{"location":"future-work/","title":"Future Work","text":""},{"location":"future-work/#creating-a-json-parser","title":"Creating a JSON Parser","text":"<p>When the Launchpad makes an HTTP GET request for user data or the nearest Pokemon, the API handlers in our Express.JS server return a newline separated payload. Rather than listing key-value pairs in a JSON format, our response only returns the values with a newline delimiter. Although this makes it easier to parse in C, it is not a robust solution. There is a lack of clarity for the meaning of each line, considering that the key is not present. We implement numerous heuristics in our parsing to verify validity of each transmission and whether certain fields are present or absent, rather than adhering to a strict grammar like JSON. As an example, our parsing logic depends on the orde rof each line. Therefore, if we extend our APIs to return additional data in the payload, we also have to change our C code to ensure that we are reading corresponding data from the correct line. This contrasts JSON notation, where the keys are not ordered, and values are instead interpreted according to the exact key it corresponds to.</p> <p>Although we initially began writing a JSON parser from scratch in C, we later found it more important to concentrate our efforts on the goals we set during our project proposal. Therefore, we converted our payloads from JSON notation to a newline separated payload. In the future, we would like to create a JSON parser so that we can return data in an effective structure that can easily be extended.</p>"},{"location":"future-work/#integrate-compass-sensor","title":"Integrate Compass Sensor","text":"<p>One of our stretch goals was to use a peripheral compass sensor that would send magnetic heading data to the Launchpad. We would then use this compass to determine the direction to the nearest Pokemon by calculating the vector from the user\u2019s GPS coordinates to the nearest Pokemon\u2019s GPS coordinates, and then calculating the angular offset from the direction that the Launchpad is pointing. Then, we would render an arrow in a virtual compass on the landing page to direct the user in the direction toward the nearest Pokemon.</p> <p>The day before our project verification day, we had finished all of our minimal and target goals and also numerous of our stretch goals, so we attempted to try implementing a Bosch BMM150 magnetometer to retrieve magnetic heading data. However, we quickly found out that integrating a magnetometer without any existing library code was a monumental challenge.</p> <p>In particular, we discovered that each individual magnetometer needs to be calibrated to account for its own imprecisions from its manufacturing, as well as the particular magnetic field strengths as derived from the Earth\u2019s field in our particular geographic region. In particular, we noted that we needed to perform two forms of calibration. A \"hard iron calibration\" is performed to compensate for local disturbances in the regional magnetic field caused by nearby objects such as small magnets. Then, a \"soft iron calibration\" is performed to compensate for any inaccuracies in the relative strength of the magnetic field along any of the euclidean axes when rotating the magnetometer along any axis.</p> <p>These calibrations are complicated and are usually performed with existing calibration software, using better documented boards with existing libraries, such as an Arduino or a Raspberry Pi. On the Launchpad CC3200, we lacked any code to assist us in performing magnetometer calibration. Thus, after approximately four hours of attempting to perform temporary calibrations, we decided to move on to abandoning the compass approach and instead polishing the rest of the project. Without any calibration, the magnetometer would return widely varying values depending both on its absolute location and rotation even when moving the magnetometer around just inches at a time. Thus, the magnetometer was impossible to use in an uncalibrated form.</p> <p>It was after attempting the compass module that we then implemented one of our other stretch goals, which was to implement a real-time web map of the Pokemon. This provided similar functionality of guiding the user to the nearest Pokemon.</p>"},{"location":"implementation/","title":"Implementation","text":""},{"location":"implementation/#gps-driver-code","title":"GPS Driver Code","text":""},{"location":"implementation/#configure-uart-interrupts","title":"Configure UART interrupts","text":"<p>The GPS module uses the UART protocol to transmit data. To set up communication between the CC3200 LaunchPad and GPS module, we enable UART1 on SysConfig and configure GPIO 11 (Pin 02) as the RX pin and GPIO 03 (Pin 58) as the TX pin. In our circuit, we connect UART1 RX and TX pins on the LaunchPad to the TX and RX pins of the GPS module, respectively. To implement UART interrupts, we closely reference our implementation from Lab 3 (\"IR Remote Control Texting Over a UART Link\") and the UART API. For UART data transmissions, the CC3200 utilizes a 16-byte receive FIFO buffer. When GPS data is written to the RX pin of UART1, each byte is appended to the FIFO buffer, from which we read the data. We use <code>UARTFIFOLevelSet</code> to assign the receive FIFO interrupt level as <code>UART_FIFO_RX4_8</code>. As a result, an interrupt is generated for every 8 bytes written to the receive FIFO buffer.</p>"},{"location":"implementation/#uart-interrupt-handler","title":"UART interrupt handler","text":"<p>For every 8 bytes written to the receive FIFO butter, the UART interrupt handler is executed. This interrupt service routine is responsible for reading the NMEA-0183 sentences. When a sentence of type \"GNGGA\" is read, it parses the latitude and longitude to assign to the game state. Aceinna OpenRTK Developer manual provides an example of a \"GNGGA\" sentence from the NMEA-0183 standard. We include that example for reference below. It is a comma-delimited sentence that starts with <code>$</code> and ends with <code>\\r\\n</code>.</p> <pre><code>$GNGGA,072446.00,3130.5226316,N,12024.0937010,E,4,27,0.5,31.924,M,0.000,M,2.0,*44 \n</code></pre> <p>For each byte in the receive FIFO buffer, <code>UARTCharGet</code> is used to read the character and remove it from the buffer. We declare a <code>volatile</code> array of <code>char</code> named <code>rx_buffer</code> that is large enough to store a single NMEA-0183 sentence. We also declare <code>rx_buffer_idx</code> \u2013 a variable to store the current length of the NMEA-0183 sentence that we are reading. When we read <code>$</code>, we also write the following bytes to a second <code>volatile</code> buffer, named <code>sentence_type</code>, until we reach the first comma delimiter.</p> <p>Reading <code>\\n</code> indicates that we have finished reading an entire NMEA-0183 sentence to <code>rx_buffer</code>. We check if <code>sentence_type</code> stores the string <code>GNGGA</code>. If so, we parse <code>rx_buffer</code> to obtain the latitude and longitude. Afterwards, we reset <code>rx_buffer_idx</code> to zero, so we can read a new NMEA-0183 sentence to <code>rx_buffer</code>.</p>"},{"location":"implementation/#parse-rx_buffer","title":"Parse <code>rx_buffer</code>","text":"<p>When an entire \"GNGGA\" sentence has been read to <code>rx_buffer</code>, we use <code>strtok</code> to parse the comma-delimited string into an array of <code>tokens</code>. To check if this is a valid GPS reading in North America, we confirm that fourth field \u2013 direction of latitude \u2013 and sixth field \u2013 direction of longitude \u2013 are \"N\" (i.e., north) and \"W\" (i.e., west), respectively. We also confirm that the latitude and longitude are not empty fields, which can occur when the GPS failed at finding a fix.</p> <p>According to Trimble's guide on NMEA-0183 messages, an NMEA-0183 sentence formats the latitude as \"ddmm.mmmm\" and longitude as \"dddmm.mmmm\", where \"dd\" and \"ddd\" represent degrees while \"mm.mmmm\" denote minutes. We reference this StackOverflow answer to convert the values to decimal degrees \u2013 a common way to express latitude and longitude values. After converting the strings to floats, we divide the minutes by 60 and add this quotient to the degrees. Since North America is located in the western hemisphere, we negate the latitude. </p>"},{"location":"implementation/#set-baudrate","title":"Set baudrate","text":"<p>By connecting the LaunchPad's UART1 TX pin to the GPS module's RX pin, we can write commands to the GPS module for configuration. By default, our GPS module communicates at a baud rate of 115200. Initially when we attempted sending the GPS module's generated NMEA sentences to the LaunchPad using the default 115200 baud, we noticed that the messages were being received incomplete. Notably, sentences would be received cut-off such as in the following example: <code>$GNGGA,072446.00</code>. Here, only the timestamp of the GNGGA sentence is being received, but otherwise the 16 character FIFO buffer is filled up and unable to receive the rest of the message before the LaunchPad code is fast enough to read the buffer. By halving the baud to 57600, we were able to slow the message transmission enough to allow the LaunchPad to read the message faster than it is transmitted.</p> <p>Changing the baud is an involved process. Firstly, the specific GPS module that we use is the HGLRC M100-5883.  This package specifically uses the UBlox M10 series baseband GPS chip. That chip uses the UBlox Protocol which specifies the supported NMEA output as well as the format for configuring the chip itself.</p> <p>For configuring the baud rate on the UBlox chip, first we reference section 21.12 of the UBlox protocol specification  which specifies sending a UART message to the RX pin of the UBlox chip with header <code>$PUBX,41,1</code>. Then, as shown in the following screenshot from the documentation, we append the fields <code>,0007,0003</code> to update UART baudrate specifically. </p> <p></p> <p>Then, we append <code>,57600</code> to specify the new baudrate. Next, we append <code>,0</code> as the default option for \"autobauding,\" which we do not concern ourselves with. Finally, we must calculate and append a checksum value beginning with an asterisk and then followed by the one-byte checksum value in hexadecimal format.</p> <p>In this case, the command string is:</p> <pre><code>$PUBX,41,1,0007,0003,57600,0\n</code></pre> <p>For the UBlox checksum, we calculate the XOR8 checksum. The XOR8 checksum simply takes each byte of the message and then computes the bitwise exclusive-or operation on each successive byte, returning a final checksum byte. We use this online tool to calculate the checksum for <code>PUBX,41,1,0007,0003,57600,0</code> which is the same command string as above except without the leading $ character.</p> <p>Thus, the resulting checksum in hexadecimal is <code>2b</code>. Finally, this is appended to the original message to result in a final command message of <code>$PUBX,41,1,0007,0003,57600,0*2b</code>.</p> <p>After this command is sent to reconfigure the baudrate of the GPS module, we then change the UART controller configuration for the UART1 interface to use 57600 baud by calling the <code>UARTConfigSetExpClk()</code> function as follows:</p> <pre><code>MAP_UARTConfigSetExpClk(\n    UARTA1_BASE,\n    MAP_PRCMPeripheralClockGet(PRCM_UARTA1),\n    57600,\n    (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |\n     UART_CONFIG_PAR_NONE)\n);\n</code></pre> <p>After updating the baudrate value, we restart the program, but while keeping the LaunchPad and thus the GPS module powered throughout, ensuring not to lose the temporarily updated baudrate.</p> <p>We then attach a Saelee logic analyzer to the RX pin of the GPS module and capture a sample NMEA sentence to ensure that the baudrate remains at 57600.</p> <p>Next, we construct a command to save the configuration of the GPS module to the GPS module's onboard non-volatile memory.</p> <p>In particular, we reference the following UBlox protocol section 31.2.1 which instructs transmitting a UART message to the UBlox chip RX pin with header bytes <code>0xB5 0x62 0x06 0x09</code>. </p> <p></p> <p>Then, we append the byte <code>13</code> in decimal to indicate a payload length of 13 bytes. Finally, we append the payload of 32 <code>0</code> bits for the <code>clearMask</code> and <code>loadMask</code> values, and then bytes <code>0xFF 0xFF 0x00 0x00</code> for the <code>saveMask</code>. According to the following screenshot from section 31.2.1, setting the lower two bytes to all ones will cause all of the GPS module's current configuration to be saved: </p> <p></p> <p>Then, according to the bottom of section 31.2.1, we set the 13th bit of the payload to <code>0xF</code> to flash the configuration to all the available memory sources, importantly including the non-volatile sources: </p> <p></p> <p>Finally, this command takes two separate checksum values. The two checksums are likely because the command is critical to receive correctly; a corrupt saved configuration would essentially brick the GPS module unless the user is successfully able to reverse engineer and then communicate with the corrupted configuration.</p> <p>The two checksums <code>CK_A</code> and <code>CK_B</code> are computed as follows:</p> <p></p> <p>CK_A and CK_B are appended to the payload.</p> <p>Finally, this entire message is written at once to the UBlox chip over UART. We remove power from the GPS module for 10 seconds and then re-attach power to ensure that the new baudrate is permanently stored in non-volatile memory.</p>"},{"location":"implementation/#disable-and-re-enable-interrupts","title":"Disable and re-enable interrupts","text":"<p>The HGLRC UBlox GPS module sends approximately 15 NMEA sentences, each 10 times per second. Each NMEA sentence is around 50 characters. Approximately 7500 bytes per second of constantly interrupting the LaunchPad causes a resource hogging problem where other program behavior, such as network requests and OLED screen updates, either don't run predictably or stop working for long periods of time.</p> <p>To fix this, we implement a solution where the UART1 RX buffer interrupt handler is initially disabled, and then remains disabled until approximately 2 seconds pass. We hand-tune this interval, eventually settling on a constant in our <code>gpg.c</code> file that we define as <code>const int GPG_READ_LIMIT = 60000</code>. How this works is that on every iteration of our main game loop in <code>game.c</code>, a function <code>PollEnableGPS()</code> is called which will increment a counter <code>gpg_read_timeout</code>. Then, when <code>gpg_read_timeout</code> reaches <code>GPG_READ_LIMIT</code> the UART1 RX buffer interrupt handler is re-enabled, allowing the board to respond to and process the influx of GPS NMEA sentences. Then, when the GPGGA sentence is fully parsed, the UART1 RX buffer is disabled again. This strategy allows the board to sample the GPS NMEA sentences at a much slower rate that is acceptable, allowing other program processes to have enough time to execute successfully at their own respective rates.</p>"},{"location":"map/","title":"Map","text":""}]}