{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>To showcase the knowledge we gained from the course EEC 172 \u2013 Embedded Systems, we exercise the skills taught in labs to design and implement a final project with increased complexity and creativity. Our project is titled Pok\u00e9mini Go, an application that is inspired by the popular game Pok\u00e9mon Go. For context, Pok\u00e9mon Go is a mobile application that uses augmented reality and the phone's GPS sensor to spawn collectible characters, called Pok\u00e9mon, on a real-world map. To capture Pok\u00e9mon, users must physically walk to real-world locations where the characters had spawned. As the user physically moves, their real-time location updates on a map displayed in the application. When the user reaches close proximity to that Pok\u00e9mon, they can attempt to catch it and add it to their collection. Our project Pok\u00e9mini Go is a simplified version of Pok\u00e9mon Go. Pok\u00e9mini Go implements the core functionality of Pok\u00e9mon Go by spawning Pok\u00e9mon characters at real coordinates. Users must walk to these coordinates to battle the Pok\u00e9mon and add it to their collection.</p>"},{"location":"#demo","title":"Demo","text":""},{"location":"#capturing-a-pokemon","title":"Capturing a Pok\u00e9mon","text":""},{"location":"#fleeing-a-pokemon","title":"Fleeing a Pok\u00e9mon","text":""},{"location":"#map-page-functionality","title":"Map Page Functionality","text":""},{"location":"bill-of-materials/","title":"Bill of Materials","text":""},{"location":"bill-of-materials/#available-lab-materials","title":"Available lab materials","text":"<p>The following list specifies necessary hardware components that were made available without purchase from the lab section. We utilized the CC3200 LaunchPad and OLED that were provided during the first session of lab 1 (\"Development Tools Tutorial and Lab Introduction\"). Furthermore, we used the IR remote, decoder, resistor, and capacitor that were handed out for lab 3 (\"IR Remote Control Texting Over a UART Link\"). To solder pin headers onto the GPS and compass modules, we used the soldering iron and solder wire that were available in the lab room.</p> <ul> <li>1 CC3200 LaunchPad (Lab Provided)</li> <li>1 AT&amp;T S3 IR universal remote control to provide user input (Lab Provided)</li> <li>1 Vishay TSOP383xx to decode IR remote signals (Lab Provided)</li> <li>1 100\u03a9 resistor to construct a low-pass filter for filtering noise on the IR decoder\u2019s power source (Lab Provided)</li> <li>1 100\u00b5F capacitor to construct a low-pass filter for filtering noise on the IR decoder\u2019s power source (Lab Provided)</li> <li>1 RGB 128x128 Adafruit SSD1351 OLED Display to display pages for the user interface (Lab Provided)</li> <li>1 soldering iron to solder pin headers onto the GPS and compass modules (Lab Provided)</li> <li>1 pack of solder wire to solder pin headers onto the GPS and compass modules (Lab Provided)</li> </ul> <p>Furthermore, we already owned an 830-tie point breadboard and a set of breadboard jumper wires to physically connect the components. We also owned pin headers to solder onto the GPS and compass modules.</p>"},{"location":"bill-of-materials/#purchased-equipment","title":"Purchased equipment","text":"<p>In addition to the equipment we personally owned or acquired from lab, we needed three other products that required purchasing: a breadboard power supply, GPS module, and compass module (to prepare for attempting our compass stretch goal). In total, we spent $42.47 excluding tax.</p>"},{"location":"bill-of-materials/#breadboard-power-supply","title":"Breadboard power supply","text":"<p>A breadboard power supply is required to make our device an interactive handheld device so that the Launchpad does not need to be connected to a computer for power. The SunFounder BreadVolt module consists of a recharge-able battery and two power outputs for 5-volts and 3.3-volts. The 5-volt output supplies power to the GPS module. The 3.3-volt output supplies power to the LaunchPad, IR receiver, and OLED display. This product was purchased on Amazon for $9.99 at this link.</p>"},{"location":"bill-of-materials/#gps-module","title":"GPS module","text":"<p>To retrieve the user\u2019s real-time location as they physically move, our project requires a GPS module so we can read the latitude and longitude. We purchased a HGLRC M100-5883 GPS module on Amazon for $19.99 at this link.</p>"},{"location":"bill-of-materials/#compass-sensor","title":"Compass sensor","text":"<p>For a stretch goal, we thought about integrating a compass sensor for rendering an arrow that directs the user to the nearest Pok\u00e9mon. Thus, we bought a Waveshare Bosch BMM150 3-axis digital compass sensor. The product was purchased on Amazon for $12.49 at this link.</p>"},{"location":"challenges/","title":"Challenges","text":"<p>We encountered a couple of major challenges during the implemen- tation of our project.</p>"},{"location":"challenges/#unable-to-connect-to-common-https-endpoints","title":"Unable to connect to common HTTPS endpoints","text":"<p>Our initial idea was to have the Launchpad make HTTPS requests to an AWS Lambda endpoint. AWS Lambda is a \"serverless\" compute service. That is, it runs a defined function when an HTTP endpoint is called, and thus allows us to write API handlers without having to manually configure and maintain any extra server infrastructure. However, we encountered major difficulties when attempting to establish a TLS connection to the Lambda endpoint. At first, we attempted establishing a TLS connection to the lambda endpoint using the same TLS root, client, and private certificates that we had configured from Lab 4. However, we received error code <code>-6</code> from the function <code>sl_Connect()</code>, indicating that a connection could not be established on the configured TLS socket. We then attempted manually downloading and flashing the AWS CA Root Certificate onto the Launchpad. We verified that the certificate was in DER format and also attempted consolidating it with intermediary certificates used on our particular Lambda endpoint into other DER files. However, none of these certificate chains permitted a successful TLS connection. After reading through AWS Lambda TLS documentation on supported TLS ciphers, we hypothesized that perhaps the default directly-exposed Lambda certificate required the use of recent ciphers that the Launchpad did not support. Thus, we also tried configuring an API Gateway, which is an AWS service for a REST API front-end that allows for more fine-grained configuration of API endpoints. In particular, API Gateway supports lower security levels and older ciphers to be explicitly configured on select endpoint paths to support older clients. However, we could not establish a TLS connection to the API Gateway either.</p> <p>We also considered using MQTT and just using the IoT shadow endpoint as previously used in Lab 4. For MQTT, we read through the sample client code provided in the TI SDK. However, we realized that the MQTT code required the use of lightweight operating systems, namely Ti-OS or FreeRTOS, which use hardware interrupts to implement pre-emptive scheduling for multitasking. If we were to adapt either of the recommended MQTT clients, then we would have to rewrite all of our logic to use those operating systems, and given that we had around 4 days at that point to get a fully working project while balancing other classes, we decided we did not have enough time to experiment with MQTT.</p> <p>The other option was using IoT shadow. However, we determined that IoT shadow would add another layer of indirection and thus complexity, since we would still need some kind of business logic layer such as a Lambda function to compute operations on the database, and as well as maintaining the separate <code>reported</code> and <code>desired</code> IoT Shadow states.</p> <p>Thus, we decided instead to simply implement an unsecured HTTP endpoint on an AWS EC2 VPS instance that we already rent yearly. This is where we decided to use Express.JS to implement this HTTP API endpoint, and so then we have this service scheduled to automatically run using Node.JS on the VPS.</p> <p>This was a simple solution permitted under the project constraints that allowed us to hit all of our minimal, target, and numerous of our stretch goals on-time.</p>"},{"location":"challenges/#unable-to-receive-a-full-nmea-sentence","title":"Unable to receive a full NMEA sentence","text":"<p>Initially when we attempted reading the GPS module NMEA sentences over UART and printing these sentences out into the computer UART console, we discovered that we were never reading a full NMEA sentence. Specifically, our GNGGA sentence would always cap at 16 bytes/ASCII characters.</p> <p>We remembered from Lab 3 that this maximum value was suspiciously similar to the buffer size of the UART FIFO buffer. Thus, we immediately suspected a similar issue as to what we had in Lab 3, where our RX buffer interrupt handler was not reading received bytes fast enough to clear the buffer and allow for the rest of the message to be received.</p> <p>Firstly, we tried setting the baudrate to the minimum allowed setting. However, for our particular board and chip, the HGLRC M100-5883 with a UBlox M10 baseband chip, the minimum UART speed that we were able to observe a valid response was 19200 baud. Even at this baudrate, we still were only able to read the first 16 characters of any NMEA message.</p> <p>Then, we decided another technique to also reduce the total number of interrupts that we would have to trigger. Instead of triggering the UART RX interrupt handler on every received byte, we instead configured our RX buffer interrupt handler to run only after every 8th received byte - a half full buffer:</p> <pre><code>MAP_UARTFIFOLevelSet(UARTA1_BASE, UART_FIFO_TX4_8, UART_FIFO_RX4_8);\n</code></pre> <p>After setting this new interrupt trigger, we were able to observe full NMEA sentences for all transmitted sentences. We hypothesize that this made such a big difference because it takes a significant amount of time to altogether raise the interrupt line, enter the interrupt service routine, run the peripheral code we implement to read the buffer characters and parse them, and then return control back to the main process. Thus, we divide the total amount of interrupt handles by a factor of 8, significantly increasing the rate at which we can handle incoming UART data.</p> <p>Lastly, although we at first tested this working solution at 19200 baud, we then decided to increase the baudrate back up to 57600 baud, which is the highest baud at which we were able to consistently receive correct NMEA sentences. The reason for attempting to drive the baudrate back up is because of the high throughput of data transmitted by the GPS module. Thus, to not hog resources away from other actions in the game loop, we try to make the transmission and receipt of GPS data as fast as possible. As is discussed above, we also combine this with the GPS module timeout where we disable the GPS UART RX interrupt when not in use.</p>"},{"location":"description/","title":"Description","text":"<p>To showcase the knowledge we gained from the course EEC 172 \u2013 Embedded Systems, we exercise the skills taught in labs to design and implement a final project with increased complexity and creativity. Our project is titled Pok\u00e9mini Go, an application that is inspired by the popular game Pok\u00e9mon Go. For context, Pok\u00e9mon Go is a mobile application that uses augmented reality and the phone's GPS sensor to spawn collectible characters, called Pok\u00e9mon, on a real-world map. To capture Pok\u00e9mon, users must physically walk to real-world locations where the characters have spawned. As the user physically moves, their real-time location is updated on a map displayed in the application. When the user reaches close proximity to that Pok\u00e9mon, they can attempt to catch it and add it to their collection. Our project Pok\u00e9mini Go is a simplified version of Pok\u00e9mon Go. Pok\u00e9mini Go implements the core functionality of Pok\u00e9mon Go by spawning Pok\u00e9mon characters at real-world coordinates. Users must walk to these coordinates to battle the Pok\u00e9mon and add it to their collection.</p>"},{"location":"description/#features","title":"Features","text":""},{"location":"description/#frontend","title":"Frontend","text":"<p>The user interface to Pok\u00e9mini Go is a 128x128 OLED display. We implement four different OLED pages \u2013 a landing page, collection page, fight or flee page, and fight page. We describe these pages in greater detail below.</p> <ol> <li>When the program starts finishes setup, the user is navigated to the landing    page. The landing page displays the board's real-time location in latitude    and longitude. Furthermore, the coordinates of the Pok\u00e9mon closest to the    user are displayed. This informs the user of the nearest location they can    physically approach to fight a Pok\u00e9mon. The nearest Pok\u00e9mon is calculated on    the server, and the client periodically requests that data.</li> <li>To view all the Pok\u00e9mon that the user has collected, they can navigate to a    collection page that displays character sprites for each Pok\u00e9mon in their    collection. </li> <li>When the user enters a 10-meter radius of a Pok\u00e9mon, a \"fight or flee\" page    is rendered. The user is informed that a Pok\u00e9mon nearby has been detected.    The user utilizes an IR remote to input whether they will flee or fight the    Pok\u00e9mon. If the user flees, they are redirected to the landing page.    Otherwise, the user is redirected to a fight page, where they engage in a    game to collect that Pok\u00e9mon.</li> <li>When the user is redirected to the fight page, they participate in a    turn-based attack mini-game, where they use the IR remote to provide user    input. Pressing a button from 0 to 9 on the IR remote will randomly harm    either the user or the enemy. Both the user and the enemy start with four    hearts. If the enemy is the first to lose all their hearts, the user wins and    collects the Pok\u00e9mon that had activated the fight. The user is redirected to    the collection page, where they can view the new Pok\u00e9mon in their collection.    Otherwise, if the user is the first to lose all their hearts, the Pok\u00e9mon    \"escapes\", and the user loses the opportunity to collect that Pok\u00e9mon. They    are subsequently redirected to the landing page.</li> </ol> <p>We also deploy a web application that displays a real-time map of all Pok\u00e9mon in our database. In addition to the coordinates displayed on the OLED landing page, the map serves as another interface to determine the locations at which a user can battle a Pok\u00e9mon. The map also displays a location marker for the device on which the user has accessed the website. As the user physically moves, their real-time location is updated on the map. </p>"},{"location":"description/#backend","title":"Backend","text":"<p>We implement REST APIs on an Express server that is hosted on a VPS (Virtual Private Server), and use AWS DynamoDB to store Pok\u00e9mon and user data. We provide the following description as a brief overview of the high-level functionality that our backend offers. When a LaunchPad runs our application, its MAC address is obtained to check whether this is a new or existing user. If this is a new LaunchPad that runs our application, the server creates a unique user on AWS DynamoDB, and the new user starts with an empty collection. Otherwise, if an existing LaunchPad has already run our application, their collection of Pok\u00e9mon is retrieved from the database when the program is initialized. The user's collection of Pok\u00e9mon will be rendered on the collection page. As the user physically moves, the LaunchPad periodically makes HTTP GET requests for the Pok\u00e9mon closest to them. When the server makes these distance calculations, it performs additional calculations to ensure that enough Pok\u00e9mon have spawned around the user. In particular, the server will calculate if there are at least 6 existing Pok\u00e9mon in a 100 meter radius of the user; if this threshold is not met, the server generates more Pok\u00e9mon in the user's 100 meter radius. If the user is within a 10-meter radius of a Pok\u00e9mon, the server informs the LaunchPad that a fight can be activated. The \"fight or flee\" page is rendered on the OLED, and the user has the choice to flee from the Pok\u00e9mon or fight via a turn-based attack mini-game. If the user fights the Pok\u00e9mon and wins, the Pok\u00e9mon is added to the user's collection. Both a fight and flee will result in the Pok\u00e9mon being deleted from the database of available characters to be battled.</p>"},{"location":"description/#hardware","title":"Hardware","text":"<p>We use two sensing devices in our implementation of Pok\u00e9mini Go \u2013 an IR receiver and GPS module.</p>"},{"location":"description/#ir-receiver","title":"IR receiver","text":"<p>An AT\\&amp;T IR universal remote control is used to send signals to an IR receiver. We incorporate code from Lab 3 (\"IR Remote Control Texting Over a UART Link\") to decode signals for identifying specific button presses. To reduce the noise from the power source, the IR receiver is connected to a low-pass filter composed of a 100 micro-farad capacitor and 100 ohm resistor. We press buttons on the IR remote to get user input for the following functionalities: choosing to fight or flee, switching between the landing page and collection page, and playing the turn-based attack mini-game on the fight page.</p>"},{"location":"description/#gps-module","title":"GPS module","text":"<p>We utilize a GPS module to get the user's location in latitude and longitude. The module reads radio signals emitted by satellites, requiring at least three satellites to calculate a position by trilateration. After the GPS successfully finds a fix, the module transmits data using the NMEA-0183 format. Each NMEA-0183 sentence begins with the character \"$\" followed by the talker identifier and the sentence type. For our project, we parse data from the \"GNGGA\" sentence. The talker identifier \"GN\" indicates that multiple satellite systems, particularly from several constellations of the Global Navigation Satellite Systems (GNSS), are used to produce data (footnote). \"GGA\" denotes the sentence type as Global Positioning System Fix Data, which consists of 16 fields. The third and fifth fields are latitude and longitude, respectively.</p>"},{"location":"description/#protocols","title":"Protocols","text":"<p>Two hardware communication protocols are used to transmit information between the MCU and peripheral devices. We use Serial Peripheral Interface (SPI) to communicate between the CC3200 LaunchPad and OLED display. Furthermore, we use UART to read data from the GPS module and debug to a local console.</p>"},{"location":"description/#serial-periphal-interface-spi","title":"Serial Periphal Interface (SPI)","text":"<p>Serial Peripheral Interface (SPI) is a full-duplex synchronous communication protocol, which is used to transmit data between the CC3200 LaunchPad and OLED display. The protocol implements a master-slave interface, where the master (i.e. MCU) initiates communication and the slave (i.e., OLED display) responds to these requests. SPI data transmissions do not follow a standardized format but comply with device specifications. The protocol uses four point-to-point unidirectional wires as described below.</p> <ol> <li>Serial Clock (SCK): A master-to-slave wire that transmits a master-generated    clock signal.</li> <li>Slave Select (SS): A master-to-slave wire that selects the specific slave    device to enable communication with.</li> <li>Master-Out Slave-In (MOSI): A master-to-slave wire that transmits data from    the master to a slave device.</li> <li>Master-In Slave-Out (MISO): A slave-to-master wire that transmits data from a    slave device to the master.</li> </ol>"},{"location":"description/#universal-asynchronous-receivertransmitter-uart","title":"Universal Asynchronous Receiver/Transmitter (UART)","text":"<p>Universal Asynchronous Receiver/Transmitter (UART) is an asynchronous serial communication protocol that uses two one-way wires, a connection for transmitting data (TX) and another for receiving data (RX). As an asynchronous protocol, the sender and receiver agree on a baud rate to indicate how often each device should sample from their own local clocks. The sender initiates transmission by sending a predetermined start symbol, which informs the receiver to begin sampling data by the baud rate. After transmission of an \\(n\\)-symbol data frame, the sender sends a stop symbol to end communication. We make the distinction here between symbol and bit because baud rate describes sampled symbols per second, not necessarily binary bits per second. However, most electrical standards used in implementing UART use binary voltage symbols.</p>"},{"location":"description/#software","title":"Software","text":""},{"location":"description/#code-composer-studio-and-cc3200-sdk","title":"Code Composer Studio and CC3200 SDK","text":"<p>Our project is implemented in the C programming language, which we compile and load onto the CC3200 via the Code Composer Studio IDE. We build on top of the starter code provided in lab 4 (\"Introduction to AWS and RESTful APIs\") and import code from lab 2 (\"Serial Interfacing with SPI and I2C\") and lab 3 (\"IR Remote Control Texting Over a UART Link\"). In particular, lab 2 provides the OLED driver code, and our implementation of writing commands and data to the display. Our lab 3 code contains the logic for decoding IR remote signals to determine which button has been pressed. Furthermore, it implements UART interrupts for communicating with another peripheral device. We extend the application <code>aws-rest-api-ssl-demo</code> from lab 4, which contains the driver code for Texas Instruments SimpleLink CC3200 SoC, and is what we use to network with the internet using a WLAN adapter.</p>"},{"location":"description/#cc3200tool","title":"cc3200tool","text":"<p>The <code>cc3200tool</code> is a serial flash utility that allows us to program flash memory and open a pyserial terminal for UART communication between the CC3200 SoC and our local machine. The command-line utility can be installed from this repository. To open a serial port on our local machine, we execute the following commands and specify our baud rate as 115200.</p> <pre><code>conda activate cc3200\ncc3200tool term 115200\n</code></pre> <p>We also use the <code>cc3200tool</code> to write to flash memory, ensuring that our project is stand-alone. As mentioned in Lab 1 (\"Development Tools Tutorial and Lab Introduction\"), we run the following command to write <code>pokemon-go.bin</code> to <code>/sys/mcuimg.bin</code>. After the program has been written to non-volatile memory, the application will run once the LaunchPad is connected to power. Pressing the \"Reset\" button will restart the application. </p> <pre><code>conda activate cc3200\ncc3200tool --sop2 \\~dtr --reset prompt \\\n    format_flash --size 1M \\\n    write_file pokemon-go.bin /sys/mcuimg.bin\n</code></pre>"},{"location":"description/#aws-dynamodb","title":"AWS DynamoDB","text":"<p>AWS DynamoDB is used to store Pok\u00e9mon and user data on the cloud. With this NoSQL serverless database, we create two tables \u2013 <code>PokemonTable</code> and <code>UserTable</code>. <code>PokemonTable</code> consists of entries for each Pok\u00e9mon that has spawned and is available to be captured. <code>UserTable</code> contains an entry for every unique LaunchPad that has run our application and tracks all Pok\u00e9mon that each user has collected. </p>"},{"location":"description/#rest-apis-and-express","title":"REST APIs and Express","text":"<p>REST (Representational State Transfer) is a common set of guidelines for writing Web APIs. Specifically, all REST APIs have stateless calls at the API level. This means that a single call transfers some state either from the server or from the client, and without the value dependent on the status of any other call. Furthermore, REST APIs are conventionally implemented using HTTP with semantically meaningful verbs and query parameters, and with JSON being the most common payload data format for transmitting structured or relational data.</p> <p>We use Node.js and TypeScript to create an Express server, where we implement REST APIs to handle HTTP requests. To retrieve, delete, update, and perform calculations on data within AWS DynamoDB, we write REST APIs to interface the LaunchPad with the database. </p>"},{"location":"design/","title":"Design","text":""},{"location":"design/#functional-specification","title":"Functional Specification","text":""},{"location":"design/#launchpad-functional-description","title":"LaunchPad Functional Description","text":"<p>As specified in the Description section, a state machine transitioning between 4 different pages is implemented. These four pages are the landing page, the collection page, the fight-or-flee page, and the fight page.</p> <p>To begin with, when the board is powered on, the system does not transition to one of the 4 pages just yet, but instead enters a loop to attempt connecting to the pre-configured WiFi network. In this loop, the text <code>Connecting to Wifi...</code> is printed on the top of the OLED screen. Then, when the LaunchPad is finally able to connect to the specified network, then the state transitions into the initial landing page.</p> <p>In the landing page, we display the title \"Pokemini Go\" in a custom font, with a picture of a Pikachu Pok\u00e9mon in the bottom right. Then, we also show the user's GPS coordinates and the enemy's GPS coordinates on the left of the screen. On the bottom of the screen, we show an indication that pressing the number button <code>1</code> on the IR remote will switch pages to the collection page.</p> <p></p> <p>In the collection page, we show a grid of Pok\u00e9mon icons corresponding to all of the Pok\u00e9mon that the user has collected. These Pok\u00e9mon are stored in the DynamoDB document corresponding to the current LaunchPad. Upon accessing the collection page, an HTTP GET request to route <code>/users/&lt;string:userId&gt;</code> is sent to the Express.JS server to retrieve all of the Pok\u00e9mon in the user's collection. The <code>userId</code> is uniquely given by the MAC address of the LaunchPad's WiFi chip, serialized into a hexadecimal string. From the collection page, the user can navigate back to the landing page by pressing the number button <code>2</code> on the IR remote.</p> <p></p> <p>In either the landing page or the collection page, a loop is run in the background where approximately every 5 seconds, the nearby Pok\u00e9mon are queried from the Express.JS server. This query is executed by making an HTTP GET request to the route <code>/pokemon/nearby</code> on the Express.JS server.</p> <p>The response from the server includes the GPS coordinates of the nearest Pok\u00e9mon to the LaunchPad, the ID of the Pok\u00e9mon, and also a boolean flag named <code>shouldActivate</code> indicating whether that Pok\u00e9mon is near enough to the LaunchPad to trigger a \"fight-or-flee\" activation. The new enemy's GPS coordinates are applied to the landing page state. Then, if <code>shouldActivate</code> is true, a state transition is triggered to enter the fight-or-flee page.</p> <p></p> <p>In the fight-or-flee page, we render text \"Pokemon Detected Nearby\" in a custom font in the center of the screen. Then right below, we indicate that the user can press the numeric button <code>1</code> on the IR remote to fight the Pok\u00e9mon, or that they can press the numeric button <code>2</code> on the IR remote to flee the Pok\u00e9mon.</p> <p>While in the fight-or-flee page, the background loop of querying for nearby Pok\u00e9mon is halted. This way, the LaunchPad does not receive a duplicate notification to fight another Pok\u00e9mon. The fight-or-flee page will stay active until the user takes an action to navigate away from it.</p> <p>If the user presses <code>2</code> to flee the Pok\u00e9mon, then an HTTP DELETE request is sent to the route <code>/pokemon/&lt;string:pokemonId&gt;</code> with the given ID of the nearest Pok\u00e9mon that triggered the fight-or-flee page. This will cause the Pok\u00e9mon to be deleted from the DynamoDB store and thus from the map. Then, the LaunchPad state will transition back to the landing page.</p> <p>If the user presses <code>1</code> to fight the Pokemon, then the LaunchPad state transitions to the fight page.</p> <p>In the fight page, we render four hearts on the top of the screen representing the user's health, and four hearts on the bottom of the screen representing the enemy's health.</p> <p>Then, we randomly assign the 10 numeric buttons on the IR remote to either trigger the user's health to decrease by one, or the enemy's health to decrease by one. To ensure that a win or loss is guaranteed without ties, we ensure that 5 of the buttons are assigned to decrease a user heart and that the other 5 buttons are assigned to decrease an enemy heart. Given the four hearts for each user, each user starts with a health value of 4. By pressing a button, either the user's health will randomly go down by 1, or the enemy's health will randomly go down by 1. The IR remote's number button actions are set at random whenever the fight state is entered. Then, when a number button is pressed, the press is recorded. A number cannot be re-pressed within the fight page. Thus, the user must exhaust all the number buttons until either the user loses all of their hearts or the enemy loses all of their hearts.</p> <p>While in the fight page, the background process for querying the server for nearby Pok\u00e9mon is halted. This way, the user will not be prompted to attack another Pok\u00e9mon while they are still battling the current Pok\u00e9mon.</p> <p></p> <p>If the user loses all of their hearts, then the resulting behavior is similar to that of if the user decided to flee in the fight-or-flee page.</p> <p>That is, an HTTP DELETE request will be made to the route <code>/pokemon/&lt;string:pokemonId&gt;</code> on the Express.JS server to delete the Pok\u00e9mon from the DynamoDB Pok\u00e9mon collection, representing the Pok\u00e9mon fleeing. Then, the LaunchPad state will transition back to the landing page.</p> <p>If the enemy loses all of their hearts, then an HTTP POST request will be made to the route:</p> <pre><code>/users/&lt;string:userId&gt;/pokemon/&lt;string:pokemonId&gt;\n</code></pre> <p>This will cause the Pok\u00e9mon to be removed from the DynamoDB Pok\u00e9mon collection and thus be removed from the map, but the Pok\u00e9mon will then also be added to the user's Pok\u00e9mon collection, signifying that the user has collected that Pok\u00e9mon. Then, the LaunchPad state will transition to the collection page to show the newly collected Pok\u00e9mon.</p> <p>Here, we show an image of what the fight page looks like immediately after the enemy loses all of their hearts, indicating a user win:</p> <p></p>"},{"location":"design/#expressjs-server-functional-description","title":"Express.JS Server Functional Description","text":"<p>The REST API server endpoint that processes the LaunchPad's network requests is written in Express.JS, a common Node.JS framework for writing web server applications. Node.JS is a server runtime that allows writing JavaScript or TypeScript code in a server non-browser environment.</p> <p>In Express.JS, API behavior is written in a declarative and asynchronous format, where function handlers are given to each particular route that the server should implement. For our application, we implement four distinct routes.</p> <ol> <li><code>HTTP GET</code> request to the route <code>/pokemon/nearby</code> will return the nearest     Pok\u00e9mon to the requesting user. We also include some lazy-loaded behavior     within this call to manage Pok\u00e9mon map state, as will be discussed later.</li> <li><code>HTTP GET</code> request to the route <code>/users/&lt;string:userId&gt;</code> will return a list    of all Pok\u00e9mon that are currently stored in the specified user's collection.</li> <li><code>HTTP DELETE</code> request to the route <code>/pokemon/&lt;string:pokemonId&gt;</code> will delete    the specified Pok\u00e9mon from the DynamoDB Pok\u00e9mon collection, thus removing the    Pok\u00e9mon from the map.</li> <li><code>HTTP POST</code> request to the route    <code>/users/&lt;string:userId&gt;/pokemon/&lt;string:pokemonId&gt;</code> will cause the specified    Pok\u00e9mon to be added to the specified user's collection, and for the Pok\u00e9mon    to also be deleted from the Pok\u00e9mon collection to remove it from the map.    This route is for \"catching\" the Pok\u00e9mon.</li> </ol> <p>For the <code>HTTP GET</code> request to the route <code>/pokemon/nearby</code>, the server expects two URL query parameters included in the request: longitude and latitude numeric values that correspond to the GPS coordinates of the requesting user. As an example, a fully formatted call might have a URL that looks as follows:</p> <pre><code>http://&lt;server_address&gt;/pokemon/nearby?latitude=37.000000&amp;longitude=-121.000000\n</code></pre> <p>If the query parameters are not given, then the web server returns a <code>400 Bad Request</code> error.</p> <p>After parsing the user's coordinates, then the server queries DynamoDB for all Pok\u00e9mon within a 100-meter radius of the user's GPS coordinates. If there are less than 6 Pok\u00e9mon within the 100-meter radius of the user's coordinates, then the server requests for more Pok\u00e9mon to be created such that the 6 Pok\u00e9mon threshold quantity is met. These new Pok\u00e9mon are created at a radius of at least 30-meters away from the user, and within the 100-meter outer radius. The Pok\u00e9mon are generated at least 30-meters away so that the user does not immediately trigger a fight with another Pok\u00e9mon, where we force the user to walk in order to reach fighting radius of a newly generated Pok\u00e9mon. In the server, we set the fight activation radius to be 10-meters. That is, if the server calculates that the user is within 10-meters of the closest Pok\u00e9mon, then the flag <code>shouldActivate</code> is set to true in the response to indicate that the LaunchPad should transition to the fight-or-flee page.</p> <p>We set the spawning radius to be 30-meters instead of 10-meters away from the user's GPS coordinates to give a margin of 20-meters. This margin accounts for the imprecision of the GPS sensor on the LaunchPad, where the position slightly jumps around as the local coordinates are polled. This way, we can prevent an accidental immediate trigger of a Pok\u00e9mon that is truly outside of the user's 10 meter activation radius, but that otherwise may have been accidentally triggered due to the user's GPS coordinates being transiently reported as closer to the Pok\u00e9mon than the user actually is.</p> <p>Finally, before returning the nearest Pok\u00e9mon information, all of the additional Pok\u00e9mon inside of the 30-meter margin-activation radius are removed from the DynamoDB Pok\u00e9mon collection. That is, if there is a single Pok\u00e9mon inside of the 30-meter radius, then that Pok\u00e9mon is returned and not deleted. If there is more than one Pok\u00e9mon inside of the 30-meter radius, then the closest of those Pok\u00e9mon is returned, and then the other Pok\u00e9mon are deleted. If there are no Pok\u00e9mon inside of the 30-meter radius, then trivially none of the Pok\u00e9mon are deleted.</p> <p>The reason for this behavior is so that after the user fights or flees the nearest Pok\u00e9mon inside of their 10-meter activation radius, then the user will not be immediately triggered to fight another Pok\u00e9mon that is also within the margin-activation radius.</p> <p>Finally, the nearest Pok\u00e9mon is then returned to the user.</p> <p>For the <code>HTTP GET</code> request to <code>/users/&lt;string:userId&gt;</code>, the server queries DynamoDB for the list of all Pok\u00e9mon that are stored in the user's document. These Pok\u00e9mon are then simply returned back to the user.</p> <p>For the <code>HTTP POST</code> request to <code>/users/&lt;string:userId&gt;/pokemon/&lt;string:pokemonId&gt;</code> the specified Pok\u00e9mon is retrieved from the DynamoDB Pok\u00e9mon collection, deleted from the Pok\u00e9mon collection, and then re-inserted into the user's document.</p> <p>For the <code>HTTP DELETE</code> request to <code>/pokemon/&lt;string:pokemonId&gt;</code>, the specified Pok\u00e9mon is directly deleted from the DynamoDB Pok\u00e9mon collection.</p> <p>For each of the above calls, the lower-level details of the response format is discussed in the Implementation section.</p>"},{"location":"design/#website-functional-description","title":"Website Functional Description","text":"<p>For the website that we implement, we use the React.JS website framework and Vite packaging system to implement a world-map interface that shows all of the Pok\u00e9mon and their locations in close to realtime.</p> <p>In particular, we leverage the Google Maps API to render a React component for a Google Map that uses the full view-port of the browser window. Then, we render a pin for the user's current location onto the map, and then we render all of the Pok\u00e9mon from the DynamoDB Pok\u00e9mon collection onto the map, using downloaded images of the Pok\u00e9mon and rendering those Pok\u00e9mon to their respective GPS coordinates on the map.</p> <p>In a background loop, we update the user's shown location and the status of all Pok\u00e9mon every 5 seconds. In the accompanying website report to this final report document, we embed our map into a page on that website.</p> <p>Below we show an example of what our map looks like:</p> <p></p>"},{"location":"design/#system-architecture","title":"System Architecture","text":"<p>Zooming out from the specific implemented behavior, the high-level system architecture involves the peripheral I/O devices connected to the LaunchPad, the LaunchPad itself, the Express.JS server, the AWS DynamoDB schema, and the React.JS map page.</p> <p>To begin with, we consider both the IR sensor and the GPS module to be input peripherals. The IR sensor detects button presses from the AT&amp;T Universal IR Remote and sends those inputs to the LaunchPad where the game business logic then updates game state in response to those presses.</p> <p>The GPS module continuously samples the user's GPS coordinates by using satellite trilateration, and then sends these samples to the game business logic as well over UART.</p> <p>Next, the output peripheral on the LaunchPad is the OLED display. We preprocess downloaded images from the internet into RGB bitmaps that are stored in C arrays. Then, these images are rendered onto the screen depending on game state.</p> <p>As is described in the functionality section, we implement an Express.JS game server that communicates bidirectionally both with the LaunchPad and also with the AWS DynamoDB database.</p> <p>Then, we implement a data schema for our DynamoDB tables. In particular, we use two collections: a Users collection that stores one document per user, and a Pok\u00e9mon collection that stores one document per each spawned Pok\u00e9mon on the map.</p> <p>Finally, we implement a front-end map page using React.JS and the Google Maps API which reads the data stored in AWS DynamoDB to visualize the global state of the game on the map.</p> <p>The implementation details for each of these major components are discussed in the Implementation section.</p>"},{"location":"future-work/","title":"Future Work","text":""},{"location":"future-work/#create-a-json-parser","title":"Create a JSON parser","text":"<p>When the Launchpad makes an HTTP GET request for user data or the nearest Pokemon, the API handlers in our Express.JS server return a newline separated payload. Rather than listing key-value pairs in a JSON format, our response only returns the values with a newline delimiter. Although this makes it easier to parse in C, it is not a robust solution. There is a lack of clarity for the meaning of each line, considering that the key is not present. We implement numerous heuristics in our parsing to verify validity of each transmission and whether certain fields are present or absent, rather than adhering to a strict grammar like JSON. As an example, our parsing logic depends on the orde rof each line. Therefore, if we extend our APIs to return additional data in the payload, we also have to change our C code to ensure that we are reading corresponding data from the correct line. This contrasts JSON notation, where the keys are not ordered, and values are instead interpreted according to the exact key it corresponds to.</p> <p>Although we initially began writing a JSON parser from scratch in C, we later found it more important to concentrate our efforts on the goals we set during our project proposal. Therefore, we converted our payloads from JSON notation to a newline separated payload. In the future, we would like to create a JSON parser so that we can return data in an effective structure that can easily be extended.</p>"},{"location":"future-work/#integrate-compass-sensor","title":"Integrate compass sensor","text":"<p>One of our stretch goals was to use a peripheral compass sensor that would send magnetic heading data to the Launchpad. We would then use this compass to determine the direction to the nearest Pokemon by calculating the vector from the user\u2019s GPS coordinates to the nearest Pokemon\u2019s GPS coordinates, and then calculating the angular offset from the direction that the Launchpad is pointing. Then, we would render an arrow in a virtual compass on the landing page to direct the user in the direction toward the nearest Pokemon.</p> <p>The day before our project verification day, we had finished all of our minimal and target goals and also numerous of our stretch goals, so we attempted to try implementing a Bosch BMM150 magnetometer to retrieve magnetic heading data. However, we quickly found out that integrating a magnetometer without any existing library code was a monumental challenge.</p> <p>In particular, we discovered that each individual magnetometer needs to be calibrated to account for its own imprecisions from its manufacturing, as well as the particular magnetic field strengths as derived from the Earth\u2019s field in our particular geographic region. In particular, we noted that we needed to perform two forms of calibration. A \"hard iron calibration\" is performed to compensate for local disturbances in the regional magnetic field caused by nearby objects such as small magnets. Then, a \"soft iron calibration\" is performed to compensate for any inaccuracies in the relative strength of the magnetic field along any of the euclidean axes when rotating the magnetometer along any axis.</p> <p>These calibrations are complicated and are usually performed with existing calibration software, using better documented boards with existing libraries, such as an Arduino or a Raspberry Pi. On the Launchpad CC3200, we lacked any code to assist us in performing magnetometer calibration. Thus, after approximately four hours of attempting to perform temporary calibrations, we decided to move on to abandoning the compass approach and instead polishing the rest of the project. Without any calibration, the magnetometer would return widely varying values depending both on its absolute location and rotation even when moving the magnetometer around just inches at a time. Thus, the magnetometer was impossible to use in an uncalibrated form.</p> <p>It was after attempting the compass module that we then implemented one of our other stretch goals, which was to implement a real-time web map of the Pokemon. This provided similar functionality of guiding the user to the nearest Pokemon.</p>"},{"location":"implementation/","title":"Implementation","text":""},{"location":"implementation/#gps-driver-code","title":"GPS driver code","text":""},{"location":"implementation/#configure-uart-interrupts","title":"Configure UART interrupts","text":"<p>The GPS module uses the UART protocol to transmit data. To set up communication between the CC3200 LaunchPad and GPS module, we enable UART1 on SysConfig and configure GPIO 11 (Pin 02) as the RX pin and GPIO 03 (Pin 58) as the TX pin. In our circuit, we connect UART1 RX and TX pins on the LaunchPad to the TX and RX pins of the GPS module, respectively. To implement UART interrupts, we closely reference our implementation from Lab 3 (\"IR Remote Control Texting Over a UART Link\") and the UART API. For UART data transmissions, the CC3200 utilizes a 16-byte receive FIFO buffer. When GPS data is written to the RX pin of UART1, each byte is appended to the FIFO buffer, from which we read the data. We use <code>UARTFIFOLevelSet</code> to assign the receive FIFO interrupt level as <code>UART_FIFO_RX4_8</code>. As a result, an interrupt is generated for every 8 bytes written to the receive FIFO buffer.</p>"},{"location":"implementation/#uart-interrupt-handler","title":"UART interrupt handler","text":"<p>For every 8 bytes written to the receive FIFO butter, the UART interrupt handler is executed. This interrupt service routine is responsible for reading the NMEA-0183 sentences. When a sentence of type \"GNGGA\" is read, it parses the latitude and longitude to assign to the game state. Aceinna OpenRTK Developer manual provides an example of a \"GNGGA\" sentence from the NMEA-0183 standard. We include that example for reference below. It is a comma-delimited sentence that starts with <code>$</code> and ends with <code>\\r\\n</code>.</p> <pre><code>$GNGGA,072446.00,3130.5226316,N,12024.0937010,E,4,27,0.5,31.924,M,0.000,M,2.0,*44 \n</code></pre> <p>For each byte in the receive FIFO buffer, <code>UARTCharGet</code> is used to read the character and remove it from the buffer. We declare a <code>volatile</code> array of <code>char</code> named <code>rx_buffer</code> that is large enough to store a single NMEA-0183 sentence. We also declare <code>rx_buffer_idx</code> \u2013 a variable to store the current length of the NMEA-0183 sentence that we are reading. When we read <code>$</code>, we also write the following bytes to a second <code>volatile</code> buffer, named <code>sentence_type</code>, until we reach the first comma delimiter.</p> <p>Reading <code>\\n</code> indicates that we have finished reading an entire NMEA-0183 sentence to <code>rx_buffer</code>. We check if <code>sentence_type</code> stores the string <code>GNGGA</code>. If so, we parse <code>rx_buffer</code> to obtain the latitude and longitude. Afterwards, we reset <code>rx_buffer_idx</code> to zero, so we can read a new NMEA-0183 sentence to <code>rx_buffer</code>.</p>"},{"location":"implementation/#parse-rx_buffer","title":"Parse <code>rx_buffer</code>","text":"<p>When an entire \"GNGGA\" sentence has been read to <code>rx_buffer</code>, we use <code>strtok</code> to parse the comma-delimited string into an array of <code>tokens</code>. To check if this is a valid GPS reading in North America, we confirm that fourth field \u2013 direction of latitude \u2013 and sixth field \u2013 direction of longitude \u2013 are \"N\" (i.e., north) and \"W\" (i.e., west), respectively. We also confirm that the latitude and longitude are not empty fields, which can occur when the GPS failed at finding a fix.</p> <p>According to Trimble's guide on NMEA-0183 messages, an NMEA-0183 sentence formats the latitude as \"ddmm.mmmm\" and longitude as \"dddmm.mmmm\", where \"dd\" and \"ddd\" represent degrees while \"mm.mmmm\" denote minutes. We reference this StackOverflow answer to convert the values to decimal degrees \u2013 a common way to express latitude and longitude values. After converting the strings to floats, we divide the minutes by 60 and add this quotient to the degrees. Since North America is located in the western hemisphere, we negate the latitude. </p>"},{"location":"implementation/#set-baudrate","title":"Set baudrate","text":"<p>By connecting the LaunchPad's UART1 TX pin to the GPS module's RX pin, we can write commands to the GPS module for configuration. By default, our GPS module communicates at a baud rate of 115200. Initially when we attempted sending the GPS module's generated NMEA sentences to the LaunchPad using the default 115200 baud, we noticed that the messages were being received incomplete. Notably, sentences would be received cut-off such as in the following example: <code>$GNGGA,072446.00</code>. Here, only the timestamp of the GNGGA sentence is being received, but otherwise the 16 character FIFO buffer is filled up and unable to receive the rest of the message before the LaunchPad code is fast enough to read the buffer. By halving the baud to 57600, we were able to slow the message transmission enough to allow the LaunchPad to read the message faster than it is transmitted.</p> <p>Changing the baud is an involved process. Firstly, the specific GPS module that we use is the HGLRC M100-5883.  This package specifically uses the UBlox M10 series baseband GPS chip. That chip uses the UBlox Protocol which specifies the supported NMEA output as well as the format for configuring the chip itself.</p> <p>For configuring the baud rate on the UBlox chip, first we reference section 21.12 of the UBlox protocol specification  which specifies sending a UART message to the RX pin of the UBlox chip with header <code>$PUBX,41,1</code>. Then, as shown in the following screenshot from the documentation, we append the fields <code>,0007,0003</code> to update UART baudrate specifically. </p> <p></p> <p>Then, we append <code>,57600</code> to specify the new baudrate. Next, we append <code>,0</code> as the default option for \"autobauding,\" which we do not concern ourselves with. Finally, we must calculate and append a checksum value beginning with an asterisk and then followed by the one-byte checksum value in hexadecimal format.</p> <p>In this case, the command string is:</p> <pre><code>$PUBX,41,1,0007,0003,57600,0\n</code></pre> <p>For the UBlox checksum, we calculate the XOR8 checksum. The XOR8 checksum simply takes each byte of the message and then computes the bitwise exclusive-or operation on each successive byte, returning a final checksum byte. We use this online tool to calculate the checksum for <code>PUBX,41,1,0007,0003,57600,0</code> which is the same command string as above except without the leading $ character.</p> <p>Thus, the resulting checksum in hexadecimal is <code>2b</code>. Finally, this is appended to the original message to result in a final command message of <code>$PUBX,41,1,0007,0003,57600,0*2b</code>.</p> <p>After this command is sent to reconfigure the baudrate of the GPS module, we then change the UART controller configuration for the UART1 interface to use 57600 baud by calling the <code>UARTConfigSetExpClk()</code> function as follows:</p> <pre><code>MAP_UARTConfigSetExpClk(\n    UARTA1_BASE,\n    MAP_PRCMPeripheralClockGet(PRCM_UARTA1),\n    57600,\n    (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |\n     UART_CONFIG_PAR_NONE)\n);\n</code></pre> <p>After updating the baudrate value, we restart the program, but while keeping the LaunchPad and thus the GPS module powered throughout, ensuring not to lose the temporarily updated baudrate.</p> <p>We then attach a Saelee logic analyzer to the RX pin of the GPS module and capture a sample NMEA sentence to ensure that the baudrate remains at 57600.</p> <p>Next, we construct a command to save the configuration of the GPS module to the GPS module's onboard non-volatile memory.</p> <p>In particular, we reference the following UBlox protocol section 31.2.1 which instructs transmitting a UART message to the UBlox chip RX pin with header bytes <code>0xB5 0x62 0x06 0x09</code>. </p> <p></p> <p>Then, we append the byte <code>13</code> in decimal to indicate a payload length of 13 bytes. Finally, we append the payload of 32 <code>0</code> bits for the <code>clearMask</code> and <code>loadMask</code> values, and then bytes <code>0xFF 0xFF 0x00 0x00</code> for the <code>saveMask</code>. According to the following screenshot from section 31.2.1, setting the lower two bytes to all ones will cause all of the GPS module's current configuration to be saved: </p> <p></p> <p>Then, according to the bottom of section 31.2.1, we set the 13th bit of the payload to <code>0xF</code> to flash the configuration to all the available memory sources, importantly including the non-volatile sources: </p> <p></p> <p>Finally, this command takes two separate checksum values. The two checksums are likely because the command is critical to receive correctly; a corrupt saved configuration would essentially brick the GPS module unless the user is successfully able to reverse engineer and then communicate with the corrupted configuration.</p> <p>The two checksums <code>CK_A</code> and <code>CK_B</code> are computed as follows:</p> <p></p> <p>CK_A and CK_B are appended to the payload.</p> <p>Finally, this entire message is written at once to the UBlox chip over UART. We remove power from the GPS module for 10 seconds and then re-attach power to ensure that the new baudrate is permanently stored in non-volatile memory.</p>"},{"location":"implementation/#disable-and-re-enable-interrupts","title":"Disable and re-enable interrupts","text":"<p>The HGLRC UBlox GPS module sends approximately 15 NMEA sentences, each 10 times per second. Each NMEA sentence is around 50 characters. Approximately 7500 bytes per second of constantly interrupting the LaunchPad causes a resource hogging problem where other program behavior, such as network requests and OLED screen updates, either don't run predictably or stop working for long periods of time.</p> <p>To fix this, we implement a solution where the UART1 RX buffer interrupt handler is initially disabled, and then remains disabled until approximately 2 seconds pass. We hand-tune this interval, eventually settling on a constant in our <code>gpg.c</code> file that we define as <code>const int GPG_READ_LIMIT = 60000</code>. How this works is that on every iteration of our main game loop in <code>game.c</code>, a function <code>PollEnableGPS()</code> is called which will increment a counter <code>gpg_read_timeout</code>. Then, when <code>gpg_read_timeout</code> reaches <code>GPG_READ_LIMIT</code> the UART1 RX buffer interrupt handler is re-enabled, allowing the board to respond to and process the influx of GPS NMEA sentences. Then, when the GPGGA sentence is fully parsed, the UART1 RX buffer is disabled again. This strategy allows the board to sample the GPS NMEA sentences at a much slower rate that is acceptable, allowing other program processes to have enough time to execute successfully at their own respective rates.</p>"},{"location":"implementation/#ir-sensor","title":"IR sensor","text":"<p>To decode the AT\\&amp;T IR remote transmissions, we copy over our solution from Lab 3 (\"IR Remote Control Texting Over a UART Link\"). In particular, we use an AT&amp;T S3 Universal Remote configured with TV code <code>1005</code>. This remote with the given TV code generates binary pulse-width modulated signals that uniquely identify each button press. The duty cycle is near 100% as can be seen in the following example transmission: </p> <p></p> <p>We use the CC3200 Timer API to implement an interrupt-based system for measuring the pulse-width of each transmitted symbol. In particular, we configure GPIO interrupts to run on both the rising and falling edges of GPIO pin 62. We configure the first hardware timer <code>PRCM_TIMERA0</code> to reset on each rising edge, and then on the next falling edge we record the elapsed time. We consider a short pulse-width (less than 300 microseconds) to be a <code>0</code> bit, and a long pulse-width (over 3 milliseconds) to be a <code>1</code> bit. The AT&amp;T remote sends a unique 16-bit code for each button. We only need to use the number keys, so we collect the unique codes for each number key and then define constants for these 16-bit codes. As shown, numeric button 1 corresponds to code <code>0x5DAE</code>, which gets mapped to navigation into the landing page and to the fight button in the Fight-or-Flee page. Numeric button 2 corresponds to code <code>0x5DB5</code>, which gets mapped to navigation into the collection page and to the flee button in the Fight-or-Flee page.</p> <p></p> <p>Then, we define the <code>PRCM_TIMERA0</code> expiry interrupt at 20 milliseconds. We have the handler reset the read IR bits. This way, we can reset partially-completed transmissions or transmissions with errors after the completion of an IR remote transmission but before the beginning of the next transmission.</p> <p>After all 16 bits from a particular IR remote transmission have been read, then the two bytes are written to a volatile integer value named <code>encoding</code>, and then a volatile boolean variable <code>transmission_complete</code> is set to true to indicate that a button press has been fully received and parsed. Procedures from the active state in the main game loop read the <code>encoding</code> variable once, then set <code>transmission_complete</code> to true, and then finally reset <code>transmission_complete</code> back to false.</p>"},{"location":"implementation/#react-map-page","title":"React map page","text":"<p>The map page for the website is implemented in TypeScript using the React.JS web component framework and the Vite packager with <code>SWC</code> (Speedy Web Compiler) optimizations. Specifically we use the following <code>npm</code> command to create the project:</p> <pre><code>npm create vite@latest pokemini-website --\\\n  --template react-swc-ts\n</code></pre> <p>In this application, we use the <code>react-router@7</code> npm package to implement handling the different pages on the website. For simplicity sake, we simply define a single route with a <code>HashRouter</code>, thus meaning that we render our <code>&lt;Map/&gt;</code> component to the URL</p> <pre><code>https://server.nicbk.com/#/map\n</code></pre> <p>Thus, our main page layout looks as follows:</p> <pre><code>&lt;HashRouter&gt;\n  &lt;Routes&gt;\n    &lt;Route path=\"/map\" element={&lt;Map /&gt;} /&gt;\n  &lt;/Routes&gt;\n&lt;/HashRouter&gt;\n</code></pre> <p>As such, we define our map page using the <code>&lt;Map /&gt;</code> component. We set the global CSS style on the body element to have properties</p> <pre><code>body {\n  margin: 0;\n  padding: 0;\n}\n</code></pre> <p>to ensure that the map fluidly takes up exactly the whole browser viewport.</p> <p>Then, we import the <code>@vis.gl/react-google-maps@1.5.2</code> npm package, which provides React hooks and components to easily render Google Maps visualizations onto the React virtual-DOM (Document-Object Model). Using this library, we add a Google Maps interface into the Map page that takes up the whole viewport size. Then, we set the center view of the map to be at GPS coordinates</p> <pre><code>lat: 38.538496,\nlng: -121.757724\n</code></pre> <p>which is approximately at the center of UC Davis campus.</p> <p>Then, we add an <code>&lt;AdvancedMarker /&gt;</code> component, to the user's GPS coordinates, which drops a pin onto the map at the specified coordinates.</p> <p>Using the <code>@aws-sdk/client-dynamodb</code> and <code>@aws-sdk/lib-dynamodb</code> libraries, we retrieve all Pokemon from the DynamoDB Pokemon collection and render each Pokemon onto the map using <code>&lt;AdvancedMarker /&gt;</code> components at their respective GPS coordinates. Finally, we download transparent images for each of the five supported Pokemon types (Pikachu, Eevee, Lickitung, Piplup, Jigglypuff) and we set the <code>&lt;AdvancedMarker /&gt;</code> icon for these Pokemon to be their respective images.</p> <p>All of the <code>&lt;AdvancedMarker /&gt;</code> components (both the user pin and all the Pokemon pins from DynamoDB) are set to update every 5 seconds.</p>"},{"location":"implementation/#game-business-logic","title":"Game business logic","text":""},{"location":"implementation/#global-state-and-state-types","title":"Global state and state types","text":"<p>When we begin our program, we initialize the following fields in our global state.</p> <ol> <li><code>state_type</code>: the current page state our game is in. (INIT to STATE_LANDING_PAGE)</li> <li><code>socket_id</code>: the socket ID returned by <code>sl_Connect</code>. (INIT to 0)</li> <li><code>mcu_latitude</code>: the latitude read from the GPS sensor in decimal degrees. (INIT to 0)</li> <li><code>mcu_longitude</code>: the longitude read from the GPS sensor in decimal degrees. (INIT to 0)</li> <li><code>mcu_id</code>: the MAC address of the LaunchPad. (INIT to 0; the MAC address is retrieved in the <code>SetupNetwork()</code> call)</li> <li><code>enemy_uuid</code>: the UUID of the nearest Pok\u00e9mon. (INIT to 0)</li> <li><code>enemy_type</code>: the type of the nearest Pok\u00e9mon. (INIT to 0)</li> <li><code>enemy_longitude</code>: the longitude of the nearest Pok\u00e9mon in decimal degrees. (INIT to 0)</li> <li><code>enemy_latitude</code>: the latitude of the nearest Pok\u00e9mon in decimal degrees. (INIT to 0)</li> <li><code>should_fight</code>: true if the user is within the 10-meter activation radius of the Pok\u00e9mon; false otherwise. (INIT to false)</li> <li><code>local_hearts</code>: the number of hearts the current user has. (INIT to 4)</li> <li><code>enemy_hearts</code>: the number of hearts the nearest Pok\u00e9mon has. (INIT to 4)</li> <li><code>collection</code>: an array of Pok\u00e9mon the user has collected; each Pok\u00e9mon is represented as a struct that stores the Pok\u00e9mon UUID and type. (INIT to 0)</li> <li><code>collection_length</code>: the number of Pok\u00e9mon in the user's collection. (INIT to 0)</li> </ol> <p>In regards to <code>state.state_type</code>, there are four possible states in which our game can be: the home state, collection state, fight-or-flee state, or fight state. In our code, we define these states as the following:</p> <pre><code>enum StateType {\n    STATE_LANDING_PAGE,\n    STATE_FIGHT_OR_FLEE_PAGE,\n    STATE_FIGHT_PAGE,\n    STATE_COLLECTION_PAGE,\n};\n</code></pre> <p>When a new state has been assigned to <code>state.state_type</code>, we set <code>state.first_run</code> to true. <code>state.first_run</code> is used to check whether we should draw the page on the OLED. After iterating through the game loop once and rendering the new state, we set <code>state.first_run</code> to false, so we can avoid re-rendering a static page on the OLED each time state in that page updates. According to our game loop below, the game state determines which page to render and logic to perform.</p> <pre><code>void GameLoop(void)\n{\n    while (true) {\n        switch (state.state_type) {\n        case STATE_LANDING_PAGE:\n            LandingState();\n            break;\n        case STATE_FIGHT_OR_FLEE_PAGE:\n            FightOrFleeState();\n            break;\n        case STATE_FIGHT_PAGE:\n            FightState();\n            break;\n        case STATE_COLLECTION_PAGE:\n            CollectionState();\n            break;\n        }\n        ...\n    }\n}\n</code></pre> <p>If we are in <code>STATE_LANDING_PAGE</code>, the function <code>LandingState()</code> is executed. This function checks if <code>state.first_run</code> is true. If so, it draws the static images for the home page on the OLED. While there are no nearby Pok\u00e9mon to trigger the \"fight or flee\" page, the user will remain on the landing page unless they switch to the collection page, and <code>LandingState()</code> keeps executing for every iteration of the game loop. This function also reads <code>state.mcu_latitude</code> and <code>state.mcu_longitude</code>, and writes these values to the display if any digits have changed. These <code>mcu</code> state variables represent the GPS coordinates of the launchpad. As is discussed in the earlier GPS module description, after every 60000 iterations of the game loop we enable the GPS UART interrupt to update <code>state.mcu_latitude</code> and <code>state.mcu_longitude</code>. For each call to <code>LandingState()</code>, we read the boolean variable <code>transmission_complete</code>, which indicates whether the IR decoder has read a valid signal from the remote. If <code>transmission_complete</code> is true and the encoding maps to button 1, then the user has switched from the landing page to the collection page. Therefore, we update <code>state.state_type</code> to <code>STATE_COLLECTION_PAGE</code> and set <code>state.first_run</code> to true. The next iteration of the game loop will render the collection page on the OLED.</p> <p>When we render the collection page, we iterate through the array <code>state.collection</code> of type <code>struct PokemonCollectionItem</code>.</p> <pre><code>struct PokemonCollectionItem {\n    char id[64];\n    enum PokemonType type;\n};\n</code></pre> <p>As we iterate through the collection, we read <code>type</code> to determine which character sprite to draw onto the OLED. There are five possible Pok\u00e9mon types: <code>POKEMON_JIGGLYPUFF</code>, <code>POKEMON_PIKACHU</code>, <code>POKEMON_PIPLUP</code>, <code>POKEMON_LICKITUNG</code>, <code>POKEMON_EEVEE</code>. Using logic similar to the landing page, we keep executing <code>CollectionState()</code> for every iteration of the game loop. At the end of each function call, we check if <code>transmission_complete</code> is true and if the IR button <code>encoding</code> variable maps to button 2. If true, then the user has switched from the collection page to the landing page. Therefore, we update <code>state.state_type</code> to <code>STATE_LANDING_PAGE</code> and set <code>state.first_run</code> to true. The next iteration of the game loop will render the landing page on the OLED.</p> <p>When in either <code>STATE_LANDING_PAGE</code> or the <code>STATE_COLLECTION_PAGE</code>, the main game loop will execute the function <code>http_get_nearby_pokemon()</code>. After every 100,000 iterations of the main game loop, this function will make an HTTP GET request to our Express.JS server at address <code>http://server.nicbk.com:42812/pokemon/nearby</code>.</p> <p>Then, the <code>getNearbyProcessMessage()</code> function will update the <code>state.enemy_latitude</code>, <code>state.enemy_longitude</code>, and <code>state.should_fight</code> fields of the global state after parsing the received data. This retrieval period of 100,000 iterations of the main game loop is hand-tuned to be approximately a 5 second interval.</p>"},{"location":"implementation/#multi-thread-logic","title":"\"Multi-thread\" logic","text":"<p>We implement a crude system of co-operative multitasking by simply having a main game loop named <code>GameLoop()</code> that is iterated through in an infinite loop. Specifically, our loop is defined as follows:</p> <pre><code>void GameLoop(void)\n{\n    while (true) {\n        switch (state.state_type) {\n        case STATE_LANDING_PAGE:\n            LandingState();\n            break;\n        case STATE_FIGHT_OR_FLEE_PAGE:\n            FightOrFleeState();\n            break;\n        case STATE_FIGHT_PAGE:\n            FightState();\n            break;\n        case STATE_COLLECTION_PAGE:\n            CollectionState();\n            break;\n        }\n\n        PollEnableGPS();\n\n        if (state.socket_id) {\n            http_get_nearby_pokemon(state.socket_id);\n        }\n\n        if (timeout &lt; 10000) {\n            ++timeout;\n            continue;\n        }\n        timeout = 0;\n\n        if (state.should_fight) {\n            state.state_type = STATE_FIGHT_OR_FLEE_PAGE;\n        }\n    }\n}\n</code></pre> <p>To recall, for each of the functions called in <code>GameLoop()</code>, we implement timers that count iterations up to some pre-defined threshold before the actual respective behavior for that function is actually executed. In this way, we implement a system where each procedure only performs its intended action after some pre-defined interval period, where in the meantime it simply just increments a counter and then yields control back to <code>GameLoop()</code>. First, we first enter the function corresponding to handling logic specific to the currently active page state. As is discussed earlier, we have a boolean variable <code>state.first_run</code> that is initially set to false right before transitioning to a new state, and which is then set to true after the first iteration of that particular state function completes. In this way we make the initial state logic, including rendering to the OLED, only execute once for a particular state. Then, after the logic for a single iteration of that state function is finished, control is returned back up to the <code>GameLoop()</code>.</p> <p>The next procedure to be run is <code>PollEnableGPS()</code>. As is discussed earlier, this function only enables the GPS UART data handler after 60,000 main loop iterations. What will happen is that <code>PollEnableGPS()</code> will immediately yield control back to <code>GameLoop()</code> unless the counter <code>gpg_read_timeout</code> reaches 60,000. Then, when <code>gpg_read_timeout</code> reaches 60,000, then <code>PollEnableGPS()</code> will enable the UART1 GPS RX interrupt handler, allowing the Launchpad to process an NMEA GNGGA sentence before then disabling the UART1 GPS RX interrupt handler again, and thus yielding time back to other interrupt handlers and other synchronous logic.</p> <p>Then, the next function in the main loop is the call to <code>http_get_nearby_pokemon()</code>.</p> <p>This function is only called if the <code>SetupNetwork()</code> function is <code>setup.c</code> has successfully executed, ensuring that we have a valid socket initialized. As is discussed earlier, we immediately yield control back to the game loop unless 100,000 iterations of the game loop have passed. Then, we make an HTTP GET request to retrieve the information for the nearest Pokemon.</p> <p>Finally, we add the if statement to \"asynchronously\" switch into the Fight-or-Flee page into the bottom of the game loop. This check is triggered after every 10,000 iterations of the game loop, which also helps to increase efficiency by yielding to other procedures when necessary. As is discussed earlier, the <code>state.state_type</code> field is only read for transition if in the <code>STATE_LANDING_PAGE</code> or the <code>STATE_COLLECTION_PAGE</code>.</p> <p>Finally, we delegate the remaining two pages: the fight-or-flee page and the fight page to their own respective sub-sections in Implementation after these following sections. This is because they have more complicated functionality that requires more space to describe.</p>"},{"location":"implementation/#dynamodb-database","title":"DynamoDB database","text":"<p>DynamoDB is the AWS offering of a NoSQL database. That is, the database stores collections of \"documents\", which are independent pieces of JSON data that can be uploaded, queried, mutated, and deleted. We implement two collections (also known as \"tables\") in our DynamoDB database: a \"Users\" collection of which we give the identifier <code>UserTable</code> and a \"Pokemon\" collection of which we give the identifier <code>PokemonTable</code>.</p> <p>For consistency, we implement a document schema that documents inserted into either table adheres to. For the <code>UserTable</code>, documents must have the following JSON format:</p> <pre><code>{\n  id (partition key): &lt;string&gt;,\n  pokemonCollection: (array) [\n    { (UserTable pokemon item)\n      id: &lt;string&gt;\n      type: &lt;string&gt;\n    }\n    ...\n  ]\n}\n</code></pre> <p>An example user document might look as follows:</p> <pre><code>{\n  id: \"a810876e2c7f\",\n  pokemonCollection: [\n    {\n      id: \"be6e50de-b07e-4a78-a490-b2e51956cafa\"\n      type: \"jigglypuff\"\n    },\n    {\n      id: \"6a592984-d471-497b-b9da-d433eb1d92d9\",\n      type: \"eevee\"\n    }\n  ]\n}\n</code></pre> <p>For the <code>PokemonTable</code>, documents must have the following JSON format:</p> <pre><code>{\n  id (partition key): &lt;string&gt;,\n  location: (gps coordinates) {\n    latitude: &lt;number&gt;,\n    longitude: &lt;number&gt;\n  },\n  type: &lt;string&gt;\n}\n</code></pre> <p>An example Pokemon document might look as follows:</p> <pre><code>{\n  id: \"b8f691e8-0681-4c8f-bcb3-179253a1e7df\",\n  location: {\n    latitude: -121.754973,\n    longitude: 38.53739\n  },\n  type: \"pikachu\"\n}\n</code></pre> <p>For Pokemon <code>id</code> fields, we generate random UUIDv4 identifiers. For user ID fields, we construct the ID using the MAC address of the Launchpad WiFi chip serialized to a 12-digit hexadecimal string.</p>"},{"location":"implementation/#expressjs-game-server","title":"Express.JS game server","text":"<p>On our Express.JS server, we create API handlers for four different HTTP requests: getting user data, getting the nearest Pok\u00e9mon, adding a Pok\u00e9mon to the user's collection, and deleting a Pok\u00e9mon. Although JSON is the most common payload data format for structuring HTTP responses, we decide to separate fields in our HTTP response with simple newlines and no JSON formatting to make it easier to parse the response data in C.</p>"},{"location":"implementation/#get-user","title":"Get user","text":"<p>When the application is executed, the LaunchPad will immediately attempt to connect to the access point and server. If a connection has been established, we use <code>sl_NetCfgGet()</code> to retrieve the MAC address of the LaunchPad. The MAC address serves as a unique identifier to differentiate users. Afterwards, we make a HTTP GET request to retrieve user data from the following API route, using the MAC address as a path parameter to define the user ID. </p> <pre><code>/users/:userId\n</code></pre> <p>In our API handler, we check whether there is an existing user with that MAC address identifier. If there is not yet an existing user for that MAC address, we first create a new entry in <code>UserTable</code>, and their <code>userCollection</code> array is initialized to be empty. Then, we return the user document in the space-separated format as shown below:</p> <p>We include an example of the returning payload when we retrieve user data for ID \"a810876e2c3f\". This user has seven Pok\u00e9mon in their collection. In addition to the user's ID, the UUID and type of each Pok\u00e9mon in their collection are returned.</p> <pre><code>a810876e2c3f\n09b81895-3403-4ec8-8871-2869d1610e52\npiplup\n5804c146-0c24-4d78-9f50-22791dc1ff2a\neevee\n89756069-860f-4840-a9db-7bf11cf5e4d7\njigglypuff\n7b171c47-479b-4eac-8db2-c79f67b254ed\npikachu\ne6f13120-50a7-4b6d-bef5-6ad217a3339b\npikachu\n3bb0052b-be9c-43da-b280-65be82637c6c\neevee\nf430aa6b-3856-4573-bff4-698644a9efb8\npiplup\n</code></pre> <p>In the above example response, the initial line is the ID of the requesting user. Then, every Pokemon in the collection is 2 lines long, consisting of the Pokemon ID and the Pokemon type. Since we can easily detect end-of-buffer in the HTTP response handler, we don't need to explicitly specify the number of returned pokemon.</p>"},{"location":"implementation/#get-nearby-pokemon","title":"Get nearby Pok\u00e9mon","text":"<p>While the user is on the landing page or collection page, we periodically make HTTP GET requests to retrieve the coordinates of the nearest Pok\u00e9mon. If there are not enough Pok\u00e9mon within a 100-meter radius of the user, the server adds more nearby Pok\u00e9mon to the database. Furthermore, if the user is within a 10-meter radius of the nearest Pok\u00e9mon, a Fight-or-Flee page should be rendered. On our Express server, this resource is located at the following API route, where latitude and longitude are passed as query parameters. The API expects the latitude and longitude to be in the format of decimal degrees.</p> <pre><code>/pokemon/nearby?latitude=&lt;latitude in decimal degrees&gt;&amp;longitude=&lt;longitude in decimal degrees&gt;\n</code></pre> <p>An example request would look as follows:</p> <pre><code>http://&lt;server_address/pokemon/nearby?latitude=37.123456&amp;longitude=-121.123456\n</code></pre> <p>The API handler will first iterate through all Pok\u00e9mon in the database and count the number of nearby Pok\u00e9mon. For each Pok\u00e9mon, we use the Pythagorean distance formula to calculate the Euclidean distance for how far that Pok\u00e9mon is from our board's current <code>latitude</code> and <code>longitude</code>.</p> \\[ \\begin{align*} pLatitude &amp;= pokemon.location.latitude \\\\ pLongitude &amp;= pokemon.location.longitude \\\\ diff\\_x &amp;= |pLatitude - latitude| \\\\ diff\\_y &amp;= |pLongitude - longitude| \\\\ dist &amp;= \\sqrt{diff\\_x^2 + diff\\_y^2} \\\\ \\end{align*} \\] <p>If <code>dist</code> is less than the <code>POKEMON_RADIUS</code> of 100-meters, we increment our count of nearby Pok\u00e9mon. We require at least 6 Pok\u00e9mon to be located within the user's 100-meter radius. Until the count reaches this threshold, we spawn more Pok\u00e9mon within the user's radius. </p> <p>To add a nearby Pok\u00e9mon, we spawn it is within a 100-meter radius to the user but outside an <code>ACTIVATION_RADIUS</code> of 10-meters. By spawning the Pok\u00e9mon outside the <code>ACTIVATION_RADIUS</code>, we require the user to walk to the nearest Pok\u00e9mon. Otherwise, the \"fight or flee\" page can trigger without physical movement from the user. To account for GPS inaccuracies and prevent Pok\u00e9mon from spawning right at the 10-meter activation boundary, we create another constant <code>ACTIVATE_RAD_WITH_MARGIN</code> and set it to 3 * <code>ACTIVATION_RADIUS</code>, which we use to spawn new Pok\u00e9mon at least 30-meters away from the user.</p> <p>For our calculations, we generate a random radius between <code>ACTIVATE_RAD_WITH_MARGIN</code> and <code>POKEMON_RADIUS</code> at which the Pok\u00e9mon will spawn from the user. Next, we generate a random angle between 0 to \\(2\\pi\\) radians, which defines the direction from the user at which the Pok\u00e9mon will spawn. This defines the polar coordinates of the new Pok\u00e9mon with respect to the user's location.</p> \\[ \\begin{align*} randRadius &amp;= ACTIVATE\\_RAD\\_WITH\\_MARGIN + Math.random() * \\\\ &amp;\\quad (POKEMON\\_RADIUS - ACTIVATE\\_RAD\\_WITH\\_ \\\\ &amp;\\quad MARGIN) \\\\ randAngle &amp;= Math.random() * 2 * \\pi \\end{align*} \\] <p>To calculate the latitude and longitude of the new Pok\u00e9mon, we convert its location from polar to cartesian coordinates. By using the formulas \\(x = r * \\cos{\\theta}\\) and \\(y = r * \\sin{\\theta}\\), we calculate the change in \\(x\\) and \\(y\\) between the user and Pok\u00e9mon. This change in \\(x\\) is added to the user's latitude, and the resulting sum is the latitude of the new Pok\u00e9mon. Similarly, the new Pok\u00e9mon's longitude is calculated by adding the change in \\(y\\) with the user's longitude.</p> \\[ \\begin{align*} xOffset &amp;= randRadius * cos(randAngle) \\\\ yOffset &amp;= randRadius * sin(randAngle) \\\\ newX &amp;= latitude + xOffset \\\\ newY &amp;= longitude + yOffset \\\\ \\end{align*} \\] <p>We define the array <code>POKEMON_TYPES</code> to specify the 5 possible characters that can spawn: a Pikachu, Jigglypuff, Piplup, Eevee, and Lickitung. We generate a random number between 0 to 4, which is used to index into <code>POKEMON_TYPES</code> and assign a type to the new Pok\u00e9mon. After generating a UUIDv4 with the <code>crypto</code> library, we use the newly calculated latitude, longitude, and type to add the new Pok\u00e9mon to <code>PokemonTable</code> in AWS DynamoDB.</p> <p>Once the minimum threshold for nearby Pok\u00e9mon has been satisfied, we iterate through all Pok\u00e9mon once more and use the Pythagorean distance formula to calculate the Pok\u00e9mon's distance from the user. As we scan through the Pok\u00e9mon, we keep track of the nearest Pok\u00e9mon and construct an array of Pok\u00e9mon that are within the user's 10-meter activation radius. Besides the nearest Pok\u00e9mon, we delete all other Pok\u00e9mon that are within the user's 10-meter activation radius. By doing so, we prevent multiple \"fight or flee\" pages from immediately rendering one after another while the user remains stationary. The API handler returns a payload that contains the nearest Pok\u00e9mon's data and whether a \"fight or flight\" page should activate.</p> <p>When we request for the nearest Pok\u00e9mon at latitude 38.537293 and longitude -121.754578, we get the following response. According to the payload, the <code>false</code> indicates that this Pok\u00e9mon is not within the user's 10-meter radius, so the \"fight or flee\" page should not be triggered. The following lines include the nearest Pok\u00e9mon's UUID, type, latitude, and longitude.</p> <pre><code>false\nb5caa020-dd5f-432c-a8b4-cd9227c89e97\njigglypuff\n38.537607926723126\n-121.75439370435284\n</code></pre>"},{"location":"implementation/#capture-pokemon","title":"Capture Pok\u00e9mon","text":"<p>If the user has won the mini-game on the fight page, the Pok\u00e9mon that had activated the \"fight or flee\" page is appended to the user's collection. As a result, we make a HTTP POST request to the following route. The user's MAC address is passed as a path parameter for <code>:userId</code>. <code>state.enemy_uuid</code> \u2013 the UUID of the nearest Pok\u00e9mon that had activated the \"fight or flee\" page \u2013 is used for <code>:pokemonId</code>.</p> <pre><code>/users/:userId/pokemon/:pokemonId\n</code></pre>"},{"location":"implementation/#delete-pokemon","title":"Delete Pok\u00e9mon","text":"<p>In addition to capturing a Pok\u00e9mon, there are two other cases where a Pok\u00e9mon should be deleted: the user chose to flee on the \"flight or flee\" page, or the user has lost the fight mini-game. For both cases, we make a HTTP DELETE request to remove the Pok\u00e9mon from the <code>PokemonTable</code> database. This resource is defined at the following route, where the Pok\u00e9mon's UUID is used as a path parameter to define the Pok\u00e9mon ID.</p> <pre><code>/pokemon/:pokemonId\n</code></pre> <p>This operation is performed on the nearest Pok\u00e9mon that had activated the \"fight or flee\" page. We store this Pok\u00e9mon's UUID in <code>state.enemy_uuid</code>.</p>"},{"location":"implementation/#fight-or-flee","title":"Fight or flee","text":"<p>When we make HTTP GET requests for the nearest Pok\u00e9mon, the response includes a boolean that indicates whether that Pok\u00e9mon is within the 10-meter activation radius of the user. After parsing the response, the boolean is stored in <code>state.should_fight</code>. While the user is on the landing page or collection page, each iteration of our game loop checks whether this variable is set to true. If so, <code>state.state_type</code> is changed to <code>STATE_FIGHT_OR_FLEE_PAGE</code>. As a result, the next iteration of the game loop will render the \"fight or flee\" page, where the user is informed that a nearby Pok\u00e9mon has been detected. While the user is on this page, the program keeps looping until it gets valid user input from the IR remote. In particular, the user should select button 1 to fight or button 2 to flee. If the user selects to fight, <code>state.state_type</code> is assigned <code>STATE_FIGHT_PAGE</code>. Otherwise, <code>state.state_type</code> is set to <code>STATE_LANDING_PAGE</code>. The next iteration of the game loop will redirect the user to the appropriate page based on their input.</p>"},{"location":"implementation/#fight-mini-game","title":"Fight mini game","text":"<p>When the user selects to fight the Pok\u00e9mon on the \"fight or flee\" page, we render the fight page on the OLED. The fight page displays bitmap images of hearts to represent the health of the user and the enemy. Both the user and the enemy start with four hearts each. Below the heart images, we render instructions and fight results to guide the user through the game. Essentially, the user utilizes the IR remote to select among buttons 0 to 9, and each button press harms either the user or the enemy. Each digit button is mapped to one of the following <code>GameButtonStates</code> states: <code>USER_BUTTON</code>, <code>ENEMY_BUTTON</code>, and <code>TAKEN</code>. Pressing a button of state <code>USER_BUTTON</code> means that the user will win the round, and the enemy will lose a heart. Similarly, pressing a button of state <code>ENEMY_BUTTON</code> means that the enemy will win the round, and the user will lose a heart. After an enemy or user selects a button, it is assigned the <code>TAKEN</code> state.</p> <p>When we initialize the fight, we iterate through the array <code>enum GameButtonState game_buttons[10]</code> to randomly assign half of it with the <code>USER_BUTTON</code> state and the other half with the <code>ENEMY_BUTTON</code> state. Then, we render the instructions. When the user is done reading the rules, they can select any digit button to start the game. Random numbers are generated using the C standard library psuedorandom number generator <code>srand()</code>.</p> <p>The user and the enemy take turns choosing a button until one of them reaches zero hearts. The user makes the first move in the game. If the user chooses any button other than 0 to 9, a message is displayed that an invalid button has been pressed, and the user must choose from only buttons 0 to 9. If the user chooses a button of state <code>TAKEN</code>, the OLED displays a message to choose an available button, and it lists all the digit buttons that have been assigned <code>TAKEN</code>.</p> <p>When it is the enemy's turn to make a move, the program keeps selecting a random button from 0 to 9 until it finds a button that is not of state <code>TAKEN</code>. The enemy uses this button as their move.</p> <p>After the enemy or user makes a valid move, the OLED shows a message that states which button has been selected, and whether that player has won or lost. When a player loses a round, their heart count is decremented, and a bitmap image of a broken heart replaces one of their full hearts.</p> <p>If the user is the first player to lose all four hearts, a message is displayed that the Pok\u00e9mon has escaped. We assign <code>state.state_type</code> to <code>STATE_LANDING_PAGE</code> to redirect the user to the landing page. Furthermore, we make an HTTP DELETE request to remove the Pok\u00e9mon from the database. The user can select any button from 0 to 9 to exit the fight page.</p> <p>If the enemy is the first to lose all their hearts, a message informs the user that they have successfully collected the Pok\u00e9mon. We set <code>state.state_type</code> to <code>STATE_COLLECTION_PAGE</code> to redirect the user to the collection page, where they can view the new Pok\u00e9mon that has been added to their collection. We also make a HTTP POST request to add the Pok\u00e9mon to the user's collection. As previously mentioned, this API will not only update the user's collection but also delete the Pok\u00e9mon from <code>PokemonTable</code> \u2013 the database of available characters to be captured. We append the new Pok\u00e9mon to <code>state.collection</code> and increment <code>state.collection_length</code>.</p>"},{"location":"implementation/#graphics-api","title":"Graphics API","text":"<p>To include images and typography on the OLED, we render bitmaps that use the 16-bit RGB format. We used Google to find images of characters and icons, and utilized a file to C style array converter to resize and convert a colored image into an array of <code>unsigned int</code>. We include a sample output of converting an image to an array below.</p> <pre><code>#define PIKACHU_BALLOON_HEIGHT 16\n#define PIKACHU_BALLOON_WIDTH 15\n\n// array size is 480\nconst unsigned int pikachu_balloon[]  = {\n  0x961b, 0x961b, 0x961b, 0x8dda, 0x857a, ...\n  0x961b, 0x961b, 0x859a, 0xae5c, 0xae5c, ...\n  0x961b, 0x961b, 0x7d3a, 0x855b, 0x855b, ...\n  0x961b, 0x961b, 0x6434, 0x6c76, 0x855b, ...\n  0x961b, 0x8dda, 0x6c11, 0xa4ea, 0x6478, ...\n  0x961b, 0x855a, 0xb618, 0xe689, 0x84b0, ...\n  ...\n};\n</code></pre> <p>To display text in a Pokemon-esque format on the OLED, we used the site Textcraft to generate png images of text. Afterwards, we converted these images to bitmaps using the file to C style array converter.</p> <p>To display a bitmap, we defined an x-offset and y-offset in pixels to render the image at a specific location on the OLED screen. Using the offsets as well as the height and width of the bitmap, we applied <code>drawPixel(int x, int y, unsigned int color)</code> from <code>Adafruit_GFX.h</code> while iterating through the bitmap array.</p>"},{"location":"map/","title":"Map","text":""}]}